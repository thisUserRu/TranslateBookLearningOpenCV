## [П]|[РС]|(РП) Не столь простые преобразования

Уже не плохо, переходим к еще более интересным вещам. В примере 2-4 создавалась новая структура под единичное преобразование изображения. По идеи, существует возможность работать только с исходным изображением, без создания дополнительного контейнера под преобразованное изображение, но зачастую это плохая идея. Например, некоторые операторы не работают с изображениями такого же размера, типом каналов и количеством каналов, как исходное изображение. Как правило, производиться цепочка преобразований и потому использование стороннего контейнера неизбежно. 

В таких случаях, зачастую полезно использовать функции-обертки, чтобы произвести все необходимые преобразования. Рассмотрим пример сжатия изображения в 2 раза. В OpenCV это достигается при помощи функции *cvPyrDown()*, которая выполняет гауссово сглаживание, а затем удаляет каждую вторую строку из изображения. Это полезно в самых разнообразных и важных алгоритмах компьютерного зрения. Реализация функции-обертки представлена в примере 2-5.

Пример 2-5. Использование cvPyrDown() для сжатия исходного изображения в 2 раза
```cpp
IplImage* doPyrDown( IplImage* in
					,int filter = IPL_GAUSSIAN_5x5
				   ) 
{
	// Проверка деления исходного изображения на 2
	assert( in->width%2 == 0 && in->height%2 == 0 );

	// Создание контейнера с размера вдвое меньшими, чем исходное изображение. В остальном параметры те же
	IplImage* out = cvCreateImage(
						cvSize( in->width/2, in->height/2 )
						,in->depth
						,in->nChannels
					);

	// Сжатие исходного изображения
	cvPyrDown( in, out );

	return( out );
};
```

Обратите внимание, под преобразованное изображение создается новая структура на основе параметров исходного изображения. В OpenCV все важные типы данных реализованы как структуры, в которых нет private данных, и все крутится вокруг указателей на эти структуры.

Переходим к чуть более сложному примеру с использованием функции определения контура **Canny edge detector**. В этом примере результирующее изображение сохранит исходные размеры, но воспользуется только одним каналом. 

Пример 2-6. Определение контура при помощи функции Canny. Результат - одноканальное изображение
```cpp
IplImage* doCanny(
					 IplImage* in 		// Одноканальное изображение
					,double lowThresh	// Нижний порог
					,double highThresh	// Верхний порог
					,double aperture 	// Размер оператора Собеля
				 ) 
{
	// Canny работает только с одноканальными изображениями
	If(in->nChannels != 1)
		return(0);

	// Создание контейнера под результирующие изображение
	IplImage* out = cvCreateImage(
						 cvSize( cvGetSize( in ) )
						,IPL_DEPTH_8U
						,1
					);

	// Преобразования
	cvCanny( in, out, lowThresh, highThresh, aperture );
	return( out );
};
```

В итоге, можно довольно-таки легко соединять несколько различных операторов. Например, требуется уменьшить изображение в два раза, а затем найти контур в еще раз уменьшенном вдвое изображении.

Пример 2-7. Сочетание сжатия изображения (дважды) и оператора Canny
```cpp
	IplImage* img1 = doPyrDown( in, IPL_GAUSSIAN_5x5 );
	IplImage* img2 = doPyrDown( img1, IPL_GAUSSIAN_5x5 );
	IplImage* img3 = doCanny( img2, 10, 100, 3 );
	
	// делаем что-нибудь с 'img3'
	...
	// 
	
	cvReleaseImage( &img1 );
	cvReleaseImage( &img2 );
	cvReleaseImage( &img3 );
```

Важно отметить, что создание дополнительных переменных под каждое преобразование не является хорошей идеей. Зачастую, из-за своей лени, происходит утечка памяти в связи с отсутствием соответствующей функции освобождения памяти *cvReleaseImage()* в функции-обертки.

Механизм "само очистки" будет более аккуратным, если использовать эту функцию, однако существует еще одна проблема: что, если нам потребуется что-то сделать с промежуточным изображением? Ничего может не получиться из-за возможного отсутствия доступа к этому изображению. Решить проблему поможет подход из примера 2-8.

Пример 2-8. Упрощение примера 2-7
```cpp
	IplImage* out;
	out = doPyrDown( in, IPL_GAUSSIAN_5x5 );
	out = doPyrDown( out, IPL_GAUSSIAN_5x5 );
	out = doCanny( out, 10, 100, 3 );
	// делаем что-нибудь с 'out'
	...
	// 
	cvReleaseImage ( &out );
```

В заключении, стоит отметить, что освобождать память необходимо из-под выделяемой под преобразования структуры. Рассмотрим небольшой пример: указатель IplImage, возвращаемый *cvCreateFileCapture()*, указывает на структуру типа **CvCapture** и инициализируется только в момент загрузки видеофайла. Освобождение памяти, вызовом функции *cvRealeaseImage()*, приведет к некоторым неожиданным проблемам. Мораль сей басни такова: очистка мусора важна, но только мусора, которой создавали сами!
