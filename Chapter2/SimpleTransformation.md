## [П]|[РС]|(РП) Простые преобразования

Отлично, теперь с помощью OpenCV можно создать собственный видеоплеер, который не будет сильно отличатся от бесчисленного множества уже существующих плееров. Однако, предметом нашего обсуждения является компьютерное зрение и потому хочется сделать что-то большее, чем просто видеоплеер. Многие базовые задачи компьютерного зрения включают применение различного вида фильтров для обработки видео потока. Давайте попробуем модифицировать уже существующую программу путем добавления простой операции преобразования каждого кадра из видео потока.

Одна из самых простых операций это сглаживание изображения, которая эффективно снижает информативность изображения, сворачивая его гауссовой или другой аналогичной функцией ядра. Сделать нечто подобное довольно таки легко. Начнем с создания нового окна "Transform-out", где будем отображать результат преобразований. После отображения захваченного исходного кадра (функция *cvShowImage()*), произведем сглаживание изображения из кадра и отобразим в окне результата.

Пример 2-4. Загрузка и сглаживание изображения с последующим отображением результата на экране

```cpp
#include <cv.h>
#include <highgui.h>

void TransformImg( IplImage* image ) {
    cvNamedWindow( "Transform-in" );    // Окно для отображения исходного изображения
    cvNamedWindow( "Transform-out" );   // Окно для преобразованного изображения

    cvShowImage( "Transform-in", image );

    // Создание контейнера для преобразованного изображения
    // 
    IplImage* out = cvCreateImage(
         cvGetSize( image )
        ,IPL_DEPTH_8U
        ,3
    );

    // Сглаживание
    // 
    cvSmooth( image, out, CV_GAUSSIAN, 3, 3 );

    // Отображение результата преобразования
    // 
    cvShowImage( "Transform-out", out );

    // Высвобождение выделяемой памяти
    // 
    cvReleaseImage( &out );

    // Ожидание нажатия клавиши для завершения программы
    // 
    cvWaitKey( 0 );
    cvDestroyWindow( "Transform-out" );
    cvDestroyWindow( "Transform-in" );	
}

int main( int argc, char** argv ) {
    IplImage* img = cvLoadImage( argv[1] ); // Получение имени изображения
    TransformImg( img );                    // Преобразование исходного изображения
    cvReleaseImage( &img );                 // Освобождение памяти из под изображения
}
```

Ранее, новый кадр создавался при содействии функции *cvCreateFileCapture()*. Происходил покадровый перебор всех кадров из структуры **CvCapture**, один за другим, с размещением их в одном и том же указателе. В нашем случае использование данного указателя не приемлемо и потому создается собственная структура под результат сглаживания. Для этого используется новая функция *cvCreateImage()*. Аргументы функции *cvCreateImage( CvSize size, int depth, int channels )*: 
	
* size - размер существующей структуры изображения (удобно получать при помощи функции *cvGetSize()*)
* depth - тип данных для каждого канала
* channels - количество каналов

В примере 2-3 создается 8-ми битное 3-х канальное изображение того же размера, что и исходное изображение. 

Операция сглаживания это всего лишь вызов функции из OpenCV, которой передается указатель на исходное изображение, указатель на результирующее изображение, тип и параметры сглаживания. В примере 2-3 используется размытие по Гауссу с ядром 3х3.

Не забывайте освобождать ресурсы, выделенные под результирующее изображение (используйте *cvReleaseImage()*).

