## [П]|[РС]|(РП) Вторая программа - AVI видео

Воспроизводить видео в OpenCV почти также легко, как и отображать одно изображение. Разница лишь в том, что нужно организовать некий цикл для обработки последовательности кадров; также нужен способ для выхода из цикла, если фильм скучный. 

Пример 2-2. Простая программа для воспроизведения видеофайла с диска при помощи OpenCV

```cpp
#include “highgui.h”

int main( int argc, char** argv ) {
    cvNamedWindow( "PlayVideo", CV_WINDOW_AUTOSIZE );       // Создание окна
    CvCapture* capture = cvCreateFileCapture( argv[1] );    // Открытие видеофайла для формирования структуры CvCapture
    IplImage* frame;                                        // Кадр
    
    while(1) {
	    frame = cvQueryFrame( capture );    // Последовательное чтение кадров
	    
	    if( !frame ) {                      // Конец файла, кадров больше нет
	        break;
	    }
	    
	    cvShowImage( "PlayVideo", frame );  // Отображение кадра
	    char c = cvWaitKey(33);             // Ожидание 33 мс, получение ASCII кода клавиши
	    
	    if( c == 27 ) {                     // Если Esc - выход из цикла
	        break;
	    }
    }
    
    cvReleaseCapture( &capture );   // Закрытие файла
    cvDestroyWindow( "PlayVideo" ); // Уничтожение окна
}
```

Функция *main()* начинается с создания окна, в примере имя окна "PlayVideo". После начинается самое интересное.

```cpp
CvCapture* capture = cvCreateFileCapture( argv[1] );
```

Функция *cvCreateFileCapture()* принимает в качестве аргумента имя видеофайла, а возвращает указатель на структуру типа *CvCapture*. Эта структура содержит всю информацию из видеофайла, включая информацию о состоянии. 

```cpp
frame = cvQueryFrame( capture );
```

После, в цикле *while(1)*, происходит чтение видеофайла кадр за кадром. Функция *cvQueryFrame()* принимает в качестве аргумента указатель на структуру **CvCapture** и помещает последующий кадр в память (которая на самом деле часть структуры **CvCapture**). Возвращает указатель полученного кадра. В отличии от *cvLoadImage()*, которая выделяет память под изображение, *cvQueryFrame()* использует выделенную память в структуре **CvCapture**. Поэтому не требуется использовать *cvReleaseImage()* для указателя на "кадр". Вместо этого память из-под кадра будет освобождена, когда произойдет уничтожение структуры **CvCapture**. 

```cpp
c = cvWaitKey(33);

if( c == 27 ) {
    break;
}
```

После отображения кадра, программа будет ожидать нажатие клавиши в течении 33 мс. Если пользователь нажмет клавишу, то будет получен ASCII код этой клавиши; иначе будет получена -1. Если пользователь нажмет Esc (ASCII 27), то чтение кадров прекратиться. Если в течении 33 мс пользователь не нажмет клавишу, то произойдет чтение последующего кадра. 

Стоит отметить, что в этом простом примере, не происходит явного контроля скорости воспроизведения видео. Все зависит лишь от таймера *cvWaitKey()*. В более сложном проекте было бы целесообразно полагаться на скорость из структуры **CvCapture**. 

```cpp
cvReleaseCapture( &capture );
```

После окончания воспроизведения видеофайла - обработаны все кадры или пользователь нажал Esc - необходимо освободить память, связанную со структурой **CvCapture**.

