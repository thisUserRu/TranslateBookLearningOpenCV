## [П]|[РС]|(РП) Структура IplImage

Теперь, со всеми ранее полученными знаниями, можно перейти к изучению структуры *IplImage*. В сущности, это объект *CvMat*, но с некоторыми дополнениями для интерпретации матрицы как изображение. Изначально структура была частью библиотеки IPL (Intel’s Image Processing). Подробное определение структуры *IplImage* отображает пример 3-10.

Пример 3-10. Заголовок структуры *IplImage*

```cpp
typedef struct _IplImage {
	int     nSize;          // sizeof(IplImage)
	int     ID;             // Версия (=0)
	int     nChannels;      // Число каналов
	int     alphaChannel;   // Не используется в OpenCV
	int     depth;          // Глубина в битах: IPL_DEPTH_8U, IPL_DEPTH_8S, 
                            // IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F и 
                            // IPL_DEPTH_64F
	char    colorModel[4];  // Не используется в OpenCV
	char    channelSeq[4];  // Не используется в OpenCV
	int     dataOrder;      // Расположение каналов. 
                            // 0 - чередование цветных каналов 
                            // 1 - раздельное расположение цветных каналов
	int     origin;         // Начало координат
                            // 0 - верхний левый угол
                            // 1 - нижний левый угол
	int     align;          // Выравнивание строк изображения (4 или 8) 
                            // В OpenCV используется widthStep
	int     width;          // Ширина в пикселях
	int     height;         // Высота в пикселях
	struct _IplROI*         roi;        // ROI. Если NULL, то выделяется все изображение
	struct _IplImage*       maskROI;    // может быть NULL
	void*                   imageId;    // может быть NULL
	struct _IplTileInfo*    tileInfo;   // может быть NULL
	int                     imageSize;  // Память выделенная под изображение в байтах
                                        // == image->height*image->widthStep в случае 
                                        // чередования данных
	char*   imageData;          // Указатель на данные изображения
	int     widthStep;          // Число байт в одной строке изображения
	int     BorderMode[4];      // Не используется в OpenCV
	int     BorderConst[4];	    // Не используется в OpenCV
	char*   imageDataOrigin;    // Используется для правильного освобождения памяти
} IplImage;
```

Как бы безумно это не прозвучало, но стоит уделить некоторое время обсуждению некоторых переменных из этой структуры. Некоторые из них просты, однако, многие очень важны для понимания принципов работы OpenCV с изображениями. 

После вездесущих переменных ширины и высоты, наиболее важными являются переменные глубина и кол-во каналов. Переменная глубина принимает одно из множества значений, определенных в *ipl.h*, которые (к сожалению) не в полной мере были описаны в главе про матрицы. Это все из-за того, что в случае с изображением приходиться иметь дело с глубиной и количеством каналов по отдельности (тогда, как в случае с матрицами со всем сразу). Возможные значения глубины приведены в таблице 3-2.

Таблица 3-2. Типы изображений в OpenCV

| Макрос | Тип изображения |
| -- | -- |
| IPL_DEPTH_8U | Без знаковое 8-битное целое (8u) |
| IPL_DEPTH_8S | Знаковое 8-битное целое (8s) |
| IPL_DEPTH_16S | Знаковое 16-битное целое (16s) |
| IPL_DEPTH_32S | Знаковое 32-битное целое (32s) |
| IPL_DEPTH_32F | 32-битное типа float (32f) |
| IPL_DEPTH_64F | 64-битное типа double (64f) |

Возможное число каналов - 1, 2, 3, 4.

Следующие немало важные поля структуры *origin* и *dataOrder*. Переменная *origin* может принимать одно из двух значений: *IPL_ORIGIN_TL* или *IPL_ORIGIN_BL*, что соответствует верхнему левому или нижнему левому углу изображения, соответственно. Отсутствие стандартного подхода (верхний против нижнего) является важным источником ошибок в процедурах компьютерного зрения. В частности, в зависимости от того, откуда пришло изображение, какие операционная система, кодек, формат хранения и т.д. – все это влияет на расположение начала координат конкретного изображения. Например, можно подумать, что выборка из пикселей находится на лицевой стороне в верхнем квадранте изображения, в действительности же на изнаночной стороне в нижней четверти. Лучше всего проверять этот момент перед выводом изображения на экран.

Параметр *dataOrder* может принимать значения *IPL_DATA_ORDER_PIXEL* или *IPL_DATA_ORDER_PLANE*. Эти значения указывают каким образом должны быть упакованы данные по каналам, пиксель за пикселем (чередуются или стандартно).

Параметр *widthStep* содержит количество байт между пикселями одного столбца (количество байт в одной строке). Переменной ширины не достаточно для того, чтобы рассчитать это расстояние, потому что каждая строка может быть выравнена с определенным числом байт для достижения более быстрой обработки изображения; соответственно, могут существовать зазоры между окончанием i-ой строки и началом (i+1) строки. 

Параметр *imageData* содержит указатель на первую строку данных изображения. Если изображение содержит несколько плоскостей (когда *dataOrder = IPL_DATA_ORDER_PLANE*), то они размещаются последовательно, в виде отдельных изображений с *height*\**nChannels* строками, но, как правило, они чередуются таким образом, что количество строк равно высоте, а каждая строка содержит чередующие каналы. OpenCV поддерживает только *IPL_DATA_ORDER_PIXEL*, в то время как IPL/IPP поддерживает *IPL_DATA_ORDER_PIXEL* и *IPL_DATA_ORDER_PLANE*.

В заключении, регион интереса (ROI) также очень важен и является на самом деле экземпляром другой структуры, *IplROI*. *IplROI* содержит *xOffset*, *yOffset*, *width*, *height* и *coi* (канал интересов). Идея использования ROI состоит в том, что функции работают с частью, указанной в ROI, изображения, а не со всем изображением. Все функции OpenCV работают с ROI, если он установлен. Если COI не NULL, то некоторые операции будут выполняться только на указанном канале, однако, многие функции OpenCV игнорируют этот параметр.


### Доступ к данным изображения

Обычно требуется обрабатывать данные изображения быстро и эффективно. Это означает, что не стоит использовать функции вида *cvSet*\**D* или аналогичные. На самом деле, лучший путь получения данных изображения, получать данные на прямую. Теперь, зная внутреннее устройство структуры *IplImage*, можно получать данные изображения быстрее и эффективнее.

Однако, даже при наличии в OpenCV хорошо оптимизированных процедур, выполняющих большой спектр задач, всегда найдутся такие задачи, с которыми эти процедуры не справятся. Рассмотрим случай трехканального HSV изображения, в котором будем изменять насыщенность и значение цвета от 0 до 255 (максимальное значение для 8-битного изображения), оставляя оттенок неизменным. Лучше всего сделать это с использованием указателя, также как это было сделано с матрицами в примере 3-9. Тем не менее есть незначительные отличия, которые связаны с различиями в устройстве структур *IplImage* и *CvMat*. Пример 3-11 отражает наиболее быстрый способ обработки трехканального HSV изображения.

Пример 3-11. Установка "S" и "V" составляющих HSV изображения в 255

```cpp
void saturate_sv( IplImage* img ) {
    for( int y=0; y<img->height; y++ ) {
        uchar* ptr = (uchar*) (
            img->imageData + y * img->widthStep
        );
        for( int x=0; x<img->width; x++ ) {
            ptr[3*x+1] = 255;
            ptr[3*x+2] = 255;
        }
    }
}
```

В начале происходит вычисление указателя *ptr*, который указывает на начало соответствующей строки *y*. Затем значение насыщенности устанавливается в 255. Так, как это трехканальное изображение, расположение канала *c* в колонке *x* вычисляется как *3*x+c*. 

Одно важное отличие *IplImage* от *CvMat* заключается в поведении *imageData*. Данные *CvMat* являются объединением, поэтому существует возможность задать тип указателя. Указатель *imageData* задается жестко как *uchar*\*. Уже известно, что указатель данных не обязательно может быть типа *uchar*, в случае же с изображением арифметика над указателем сводится к добавлению к указателю значения *widthStep*, который так же в байтах, и потому уже не нужно беспокоиться о приведении типов, после получения результата. При работе с матрицами, необходимо уменьшать смещение, так как указатель данных не всегда может быть типа *byte*, в то время, как указатель данных изображения всегда типа *byte*, смещение можно использовать "как есть". 


### Подробнее о *ROI* и *widthStep*

*ROI* и *widthStep* имеют большое практическое значение, так как во многих ситуациях ускоряют операции компьютерного зрения, за счет обработки части изображения. Все функции OpenCV поддерживают *ROI* и *widthStep*. Для включения или выключения поддержки ROI, используются функции *cvSetImageROI()* и *cvResetImageROI()*. Т.к. выделение части изображения имеет вид прямоугольника, нужно использовать структуру *CvRect*, которую можно передать в функцию *cvSetImageROI()* для "включения ROI"; для "выключения ROI" необходимо передать указатель на изображение в функцию *cvResetImageROI()*. 

```cpp
void cvSetImageROI( IplImage* image, CvRect rect );
void cvResetImageROI( IplImage* image );
```

Чтобы увидеть, как используется ROI, рассмотрим пример загрузки и выделения некоторой области изображения. Код из примера 3-12 загружает изображение, устанавливает *x*, *y*, *width*, *height* предполагаемого ROI и объявляет целое число, для изменнеия области ROI. Затем задается область ROI, при помощи конструктора *cvRect()*. Важно выключить область ROI с помощью функции *cvResetImageROI* перед выводом изображения на экран, иначе в вывод попадет часть (область ROI) изображения. 

Пример 3-12. Использование ROI для увеличения значения пикселей в области изображения

```cpp
#include <cv.h>
#include <highgui.h>

int main( int argc, char** argv ) {
    IplImage* src;

    // argv[1] - путь до изображения
    // 
    if( argc == 7 && ((src=cvLoadImage(argv[1],1)) != 0 )) {
        int x = atoi(argv[2]);      // Отступ от левого верхнего угла изображения по оси x
        int y = atoi(argv[3]);      // Отступ от левого верхнего угла изображения по оси y
        int width = atoi(argv[4]);  // Ширина ROI
        int height = atoi(argv[5]); // Высота ROI
        int add = atoi(argv[6]);    // Значение увеличения

        // Захват области изображения. Установка ROI
        // 
        cvSetImageROI( src, cvRect(x,y,width,height) );
        
        // Сложение скаляра с изображением
        // 
        cvAddS( src, cvScalar(add),src );
        
        // Сброс ROI
        // 
        cvResetImageROI( src );

        cvNamedWindow( "Roi_Add", 1 );  // Создание окна
        cvShowImage( "Roi_Add", src );  // Вывод результата
        cvWaitKey();
    }

    return 0;
}
```

Рисунок 3-3 отображает результат выполнения примера 3-12 с добавлением *add=150* к синему каналу изображения кошки с центром ROI на лице. 

![Рисунок 3-3 не найден](Images/Pic_3_3.jpg)

Рисунок 3-3. Результат добавления 150 к синему каналу изображения

Такого же эффекта можно добиться и с использованием *widthStep*. Чтобы сделать это, необходимо создать дополнительный заголовок изображения и установить ширину и высоту в точности как у *interest_rect*. Кроме этого, необходимо установить начало координат изображения (левый верхний или левый нижний угол) в такое же положение, как у *interest_rect*. Так же установить *widthStep* в значение, равное значению *widthStep* у *interest_rect*. В заключении, установить указатель данных на начало запрашиваемой области изображения.

Пример 3-13. Использование альтернативного метода с использованием *widthStep* для изменения пикселей области изображения *interest_img*

```cpp
// interest_img - исходное изображение
// interest_rect - запрашиваемая область
// sub_img - контейнер под запрашиваемую область

// Создание заголовка изображения (контейнер)
// 
IplImage *sub_img = cvCreateImageHeader(
     cvSize(
         interest_rect.width
        ,interest_rect.height
     )
    ,interest_img->depth
    ,interest_img->nChannels
);

// Начало координат
// 
sub_img->origin = interest_img->origin;

// Шаг
// 
sub_img->widthStep = interest_img->widthStep;

// Установка указателя данных на начало (в соответствии с началом координат)
// 
sub_img->imageData = interest_img->imageData +
    interest_rect.y * interest_img->widthStep +
    interest_rect.x * interest_img->nChannels;

// Изменение пикселей запрашиваемой области
// 
cvAddS( sub_img, cvScalar(1), sub_img );

// Освобождение памяти, занимаемой контейнером
// 
cvReleaseImageHeader( &sub_img );
```

Теперь возникает вопрос, когда использовать метод с *widthStep*, а когда с ROI? Если требуется обрабатывать несколько регионов за раз, то используйте первый метод, т.к. использование ROI подразумевает захват и освобождение запрашиваемой области для каждого региона, что сказывается на производительности программы.

В заключение, пару слов о масках. Функция *cvAddS()* позволяет использовать четыре аргумента, где маска по умолчанию NULL: *const CvArr\* mask = NULL*. Это 8-битный одноканальный массив, который позволяет ограничить область обработки произвольной формы, ограниченная ненулевыми пикселями маски. Если ROI устанавливается вместе с маской, область обработки будет ограничена пересечением маски и ROI. Не все функции поддерживают маски.
