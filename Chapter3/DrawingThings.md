## (П]|(РС)|(РП) Рисование

Очень часто нам будет необходимо рисовать или писать что-либо на изображениях взятых откуда либо.OpenCV предоставляет нам такую возможность, обладая функциями способными рисовать линии, квадраты, круги и т.д. 

### Линии

Простейшая из всех функций просто рисует линию по алгоритму Bresenham65: 

```cpp
	void cvLine(
		 CvArr* 	array
		,CvPoint	pt1
		,CvPoint	pt2
		,CvScalar	color
		,int 		thickness 		= 1
		,int 		connectivity	= 8
	);
```

Первый аргумент *cvLine()* - *CvArr** указатель на изображение *IplImage**. Следующие два аргумента это *CvPoint*. Напомним, *CvPoint* это структура содержащая два целочисленных значения *x* и *y*. Можно создать *CvPoint* "на лету" с помощью функции *cvPoint(int x, int y)*. 

Следующий аргумент *color* типа *CvScalar*. *CvScalar* также является струтурой, которая определяется следующим образом:

```cpp
	typdef struct {
		double val[4];
	} CvScalar;
```

Эта структура содержит только массив из четырех чисел типа *double*. Первых три числа массива представляют цвета: красный зеленый и синий; четвертый не используется (при необходимости используется для альфа канала). Для этого аргумента удобно использовать макрос *CV_RGB(r,g,b)*. Этот макрос принимает три числа и упаковывает их в структуру *CvScalar*.

Следующие два аргумента не обязятельны. *thickness* это толщина линии (в пикселях) и *connectivity* устанавливает тип сглаживания. Тип сглаживания по умолчанию 8 - хорошо сглаженная линия. Можно также установить 4, тогда линия будет менее аккуратна, но зато времени на рисование потребуется намного меньше. 

Ещё одна удобная функция это *cvRectangle()*. Из названия понятно, что она рисует прямоугольник. Эта функция имеет теже аргументы, что и *cvLine()*, за исключением аргумента *connectivity*, т.к. стороны прямоугольника в OpenCV всегда параллельны осям координат и сглаживать их нет необходимости. В *cvRectangle()* просто передаются две точки для противоположных углов.

```cpp
	void cvRectangle(
		 CvArr* 	array
		,CvPoint 	pt1
		,CvPoint 	pt2
		,CvScalar 	color
		,int 		thickness = 1
	);
```

### Круги и эллипсы

Так же просто можно нарисовать круг, функция рисования которого в значительной степени имеет те же аргументы.

```cpp
	void cvCircle (
		 CvArr* 	array
		,cvPoint 	center
		,int 		radius
		,CvScalar	color
		,int 		thickness 	= 1
		,int 		connectivity = 8
	);
```

Для круга, прямоугольника и других замкнутых фигур, значение аргумента *thickness* может быть установлено как *CV_FILL*, что эквивалентно значению -1; как результат - фигура будет залита в тот же цвет, что и края. 

Немного более сложная, чем *cvCircle()*, функция рисует эллипс:

```cpp
	void cvEllipse(
		 CvArr* 	img
		,CvPoint 	center
		,CvSize 	axes
		,double 	angle
		,double 	start_angle
		,double 	end_angle
		,CvScalar	color
		,int 		thickness = 1
		,int 		line_type = 8
	);
```

Новый аргумент в этой функции *axes*, который имеет тип *CvSize*. Структура *CvSize* очень похожа на *CvPoint* и *CvScalar*, только содержит ширину и высоту. Как и для ** и ** есть вспомогательная функция *cvSize(int width, int height)*, которая возвращает структуру *CvSize*. В данном случае ширина и высота представляют длину большой и малой оси эллипса.

Аргумент *angle* это угол большой оси (в градусах), отсчитываемый от горизонта(т.е. от оси X) против часовой стрелки. *start_angle* и *end_angle* указывают углы (в градусах) начала и окончания дуги эллипса. Для цельного эллипса не обходимо установить эти значения в 0 и 360 соответственно.

Альтернативный способ нарисовать эллипс это использовать ограничительную рамку:

```cpp
	void cvEllipseBox(
		 CvArr* 	img
		,CvBox2D 	box
		,CvScalar 	color
		,int 		thickness	= 1
		,int 		line_type	= 8
		,int 		shift 		= 0
	);
```

В функции используется новая вспомогательная структура *CvBox2D*:

```cpp
	typdef struct {
		CvPoint2D32f	center;
		CvSize2D32f		size;
		float 			angle;
	} CvBox2D;
```

*CvPoint2D32f* аналог *CvPoint*, а *CvSize2D32f* аналог *CvSize*, только оба вещественного типа. 

### Полигоны

И в заключении, в распоряжении есть множество функций для рисования полигонов:

```cpp
	void cvFillPoly(
		 CvArr* 	img
		,CvPoint**	pts
		,int* 		npts
		,int 		contours
		,CvScalar	color
		,int 		line_type = 8
	);

	void cvFillConvexPoly(
		 CvArr* 	img
		,CvPoint*	pts
		,int 		npts
		,CvScalar	color
		,int 		line_type = 8
	);

	void cvPolyLine(
		 CvArr* 	img
		,CvPoint**	pts
		,int* 		npts
		,int 		contours
		,int 		is_closed
		,CvScalar	color
		,int 		thickness = 1
		,int 		line_type = 8
	);
```

Все три функции реализуют одну и ту же идею, с разницей в том, как представлены точки. 

В *cvFillPoly()* точки представляются в виде массива структур *CvPoint*. Это позволяет нарисовать много полигонов в одном вызове. *npts* является массивом количества точек, по одному для каждого полигона. Если переменная *is_closed* установлена в *true*, то последняя точка полигона будет автоматически соединяться с первой. *cvFillPoly()* вполне надежная функция и может обрабатывать самопересекающиеся полигоны, полигоны с отверстиями и полигоны другой сложности. Однако, это влияет на производительность. 

Функция *cvFillConvexPoly()* похожа на *cvFillPoly()*, только рисует один полигон за раз, и работает только с выпуклыми полигонами. Достоинством c*vFillConvexPoly()* является высокое быстродействие.

*cvPolyLine()* принимает те же аргументы что и *cvFillPoly()*, только рисует незакрашенный полигон и следовательно работает гораздо быстрее.

### Шрифты и текст

Ещё одна вещь которая может пригодится при обработке изображений – это отрисовка текста. Конечно текст создаёт собственный набор сложностей, но как всегда в OpenCV есть простой набор инструментов для решения этой задачи (без ненужных возможностей которые есть в других библиотеках). 

В OpenCV есть одна главная функция *cvPutText()*, которая просто помещает некоторый текст на изображение. Тектс указывается в *text* и печатается от нижнего левого угла текстового поля *origin* цвета *color*.

```cpp
	void cvPutText(
		 CvArr* 			img
		,const char*		text
		,CvPoint 			origin
		,const CvFont*		font
		,CvScalar 			color
	);
```

Однако, существую более сложные задачи, чем просто поместить текст на изображении. Для этих случаев существует указатель *CvFont*.

Для получения валидного указателя *CvFont** используется функция *cvInitFont()*. Эта функция принимает группу аргументов, которые настраивают некоторые особенности шрифта для отображения на экране. Те, кто знаком с программированием GUI в других средах, знакомы с *cvInitFont()*.

Для создания *CvFont* и передачи в *cvPutText()*, необходимо сначала объявить переменную *CvFont* и передать её в *cvInitFont()*.

```cpp
	void cvInitFont(
		 CvFont*	font
		,int 		font_face
		,double		hscale
		,double 	vscale
		,double 	shear 		= 0
		,int 		thickness 	= 1
		,int 		line_type 	= 8
	);
```

Эта функция немного отличается от аналогичных ей, например от *cvCreateImage()*. Структуру CvFont нужно создавать перед вызовом этой функции, в отличии от cvCreateImage() которая возвращает указатель, в cvInitFont() нужно передать указатель на уже существующую структуру. 

Аргумент *font_face* может быть одним из перечисленных в таблице 3-15 (и изображенном на рисунке 3-6). Также он может быть скомбинирован с *CV_FONT_ITALIC* посредством логического OR.

Таблица 3-15. Доступные шрифты

| Переменная | Описание |
| -- | -- |
| CV_FONT_HERSHEY_SIMPLEX | Нормальный размер без засечек |
| CV_FONT_HERSHEY_PLAIN | Маленький размер без засечек |
| CV_FONT_HERSHEY_DUPLEX | нормальный размер без засечек, сложнее, чем CV_FONT_HERSHEY_SIMPLEX |


| CV_FONT_HERSHEY_COMPLEX | Normal size serif, more complex than CV_FONT_HERSHEY_DUPLEX
| CV_FONT_HERSHEY_TRIPLEX | Normal size serif, more complex than CV_FONT_HERSHEY_COMPLEX
| CV_FONT_HERSHEY_COMPLEX_SMALL
Smaller version of CV_FONT_HERSHEY_COMPLEX
| CV_FONT_HERSHEY_SCRIPT_SIMPLEX | Handwriting style
| CV_FONT_HERSHEY_SCRIPT_COMPLEX | More complex variant of CV_FONT_HERSHEY_SCRIPT_SIMPLEX