## (П]|(РС)|(РП) Дискретное преобразование Фурье (ДПФ)

Для произвольного набора значений, который проиндексирован дискретным (целочисленным) параметром, возможно определить дискретное преобразование Фурье (ДПФ) (Джозеф Фурье был первым, кто обнаружил, что некоторые функции могут быть разложены в бесконечный ряд других функций - это привело к появлению раздела, называнного анализ Фурье. Некоторые ключевые моменты, связанные с разложением функций в ряд Фурье, можно найти у Morse для физиков в частности и у Papoulis в общем. Быстрое преобразование Фурье было изобретено Cooley и Tukeye в 1965, хотя основные моменты самой идеи были предложены еще Карлом Гауссом в 1805. Первое упоминание об использовании разложения в ряд Фурье в компьютерном зрении можно найти у Ballard и Brown), аналогичное по виду преобразованию Фурье для непрерывной функции. Для N комплексных чисел ![Формула 6-25 не найдена](Images/Frml_6_25.jpg) одномерное ДПФ определяется по следующей формуле (где i=![Формула 6-26 не найдена](Images/Frml_6_26.jpg)):

![Формула 6-27 не найдена](Images/Frml_6_27.jpg)

Подобное преобразование может быть определено для двумерного массива чисел (разумеется существуют аналоги и для массивов более высших порядков):

![Формула 6-28 не найдена](Images/Frml_6_28.jpg)

В общем, можно ожидать, что на вычисление N разных членов ![Формула 6-29 не найдена](Images/Frml_6_29.jpg) потребуется O(![Формула 6-30 не найдена](Images/Frml_6_30.jpg)) операций. На самом деле, существует несколько алгоритмов *быстрого преобразования Фурье* (БПФ), способных вычислять эти величины за время O(NlogN). Функция OpenCV *cvDFT()* реализует один из таких алгоритмов БПФ. Функция *cvDFT()* вычисляет БПФ для одномерных и двумерных исходных массивов. Для последнего случая, может быть вычислено двумерное преобразование, либо, если указано, одномерное преобразование для каждого независимого ряда (эта опреация намного быстрее, чем вызов *cvDFT()* для каждого отдельного случая).

```cpp
	void cvDFT(
		 const CvArr* 	src
		,CvArr* 		dst
		,int 			flags
		,int 			nonzero_rows = 0
	);
```

Исходный и конечный массивы могут быть вещественного типа одно- или двухканальными. В случае одноканального массива (исходный), элементами являются действительные значения, а выходные значения будут упакованы в специальный, компактный формат (унаследованного от старой библиотеки IPL, так же как и структура *IplImage*). В случае двухканального массива (исходный), два канала будут интерпритироваться как действительные и мнимые компоненты входных данных. В этом случае не будет никакого особенного упаковывания результатов; тем самым будет потеряно некоторое пространство, заполненное множеством нулей как в исходном, так и в конечном массивах (При использовании этого метода необходимо явно устанавливать мнимые компоненты в нули в двухканальном представлении. Простой способ сделать это - создать матрицу заполненную нулями при помощи *cvZero()* для мнимой части, а затем вызвать *cvMerge()* вместе с матрицей действительных чисел, чтобы сформировать временный массив комплексных чисел и выполнить *cvDFT()*. Эта процедура приведет к выводу полноразмерной, неупакованной, комплексной матрицы спектра).

Формат специально упакованных выходных данных для случая с одноканальным выходным массивом.

Для одномерного массива:

![Формула 6-31 не найдена](Images/Frml_6_31.jpg)

Для двумерного массива:

![Формула 6-32 не найдена](Images/Frml_6_32.jpg)

Стоит заострить внимание на индексах этих массивов. Проблема в том, что некоторые значения гарантированно нулевые (если более точно, то некоторые значения ![Формула 6-29 не найдена](Images/Frml_6_29.jpg) гарантированно только действительные). При этом стоит отметить, что последний ряд таблицы будет присутствовать только если ![Формула 6-33 не найдена](Images/Frml_6_33.jpg) нечетно, а последняя колонка будет присутствовать только если ![Формула 6-34 не найдена](Images/Frml_6_34.jpg) нечетно. (В случае двумерного массива, рассматриваемого как ![Формула 6-33 не найдена](Images/Frml_6_33.jpg) одномерных массивов, вместо полноценного двумерного преобразования, все выходные строки будут аналогичны единственной строке одномерного массива).

Третий аргумент *flags* определяет тип операции. *Прямое преобразование* устанавливается флагом *CV_DXT_FORWARD*. *Обратное преобразование* (При обратном преобразовании, входные данные упаковываются в специальный формат. Это имеет смысл, т.к. если вызвать прмое ДПФ, а затем обратное ДПФ, то результатом должны быть исходные данные - это произойден только в том случае, если используется флаг *CV_DXT_SCALE*) определяется схожим образом, за исключением смены знака у экпоненты и масштабного коэффициента. Для выполнения обратного преобразования без масштабного коэффициента, используется флаг *CV_DXT_INVERSE*. Флаг *CV_DXT_SCALE* отвечает за масштабный коэффициент - это приводит к масштабированию результата на величину 1/N (или 1/(![Формула 6-34 не найдена](Images/Frml_6_34.jpg) ![Формула 6-33 не найдена](Images/Frml_6_33.jpg)) для двумерного преобразования). Этот флаг используется, если в результате последовательности прямого и обратного преобразования над исходными данными необходимо получить исходные данные в том же виде. Т.к. довольно таки часто приходиться использовать сочетание флагов *CV_DXT_INVERSE* и *CV_DXT_SCALE*, существует несколько сокращенных записей для операций такого рода. В дополнение к простому комбинированию этих флагов при помощи операции *OR*, можно воспользоваться флагом *CV_DXT_INV_SCALE* (или *CV_DXT_INVERSE_SCALE*, если короткие записи "не по вкусу"). И последний вариант флага, который может быть задействован, *CV_DXT_ROWS* указывает *cvDFT()* обрабатывать двумерный массив как набор одномерных, каждый из которых должен быть преобразован независимо так будто имеется ![Формула 6-33 не найдена](Images/Frml_6_33.jpg) независимых векторов длинною ![Формула 6-34 не найдена](Images/Frml_6_34.jpg). Это значительно снижает накладные расходы на выполнение множества одновременных преобразований (особенно при использовании библиотеки Intel IPP). Использование флага *CV_DXT_ROWS* позволяет осуществить трехмерное (или выше) ДПФ.

Прежде, чем осознать назначение последнего аргумента *nonzero_rows*, необходимо немного отвлечься. В общем, алгоритмы ДПФ сильно зависят от длин векторов или размерностей массивов. В большинстве алгоритмах ДПФ, предпочитаемые размеры должны быть степени двойки (т.е. ![Формула 6-35 не найдена](Images/Frml_6_35.jpg) для целого n). В случае алгоритма, используемого в OpenCV, предпочтение отдается векторам длинною, или массивам размерностью, равными ![Формула 6-36 не найдена](Images/Frml_6_36.jpg) для некоторых целых p, q и r. Поэтому, как правило, в этом случае создается несколько больший массив (для этих целей существует удобная функция *cvGetOptimalDFTSize()*, которая принимает длину вектора, а возвращает первый приемлемый размер, больший или равный длине вектора) с последующим использованием *cvGetSubRect()* для копирования исходного массива в более вместительный массив с зануленным окончанием. Помимо необходимости занулять окончание, *cvDFT()* так же можно указать, что эти сторки не нужно преобразовывать, а просто добавлять после реальных данных (или, если выполняется обратное преобразование, то указать, что эти строки не нужны). В любом случае, параметр *nonzero_rows* указывает какое количество строк можно проигнорировать. Это немного экономит вычислительное время.