## [П]|(РС]|(РП) Преобразования Rodrigues

При работе с трехмерным пространством, наиболее часто встает задача вращения представлений в этом пространстве матрицы 3x3. Эти представления, как правило, наиболее удобны, т.к. перемножение вектора и данной матрицы эквивалентно повороту вектору. Недостатком является то, что может быть затруднительно интуитивно понять, как вращать матрицу 3x3. В альтернативе несколько проще визуализировать (в данном контексте "проще" не только человеку; вращение в трехмерном пространстве представляется только тремя компонентами, поэтому более эффективно обрабатывать три компоненты представления Rodrigues, чем девять компонент матрицы поворота 3x3) представление для вращения в виде вектора, для которого вся работа сводится к оперированию одним углов. В этом случае стандартная практика использовать только один вектор для управления кодированием направления оси, вокруг которой будут производиться вращения, и его размер для кодирования количества вращений против часовой стрелки. Это легко выполнимо, т.к. направление может быть одинаково хорошо представлено вектором любого масштаба; следовательно, можно выбрать величину вектора равную величине поворота. Связи между этими двумя представлениями, матрицей и вектором, охвачены преобразованием Rodrigues. Пусть r это трехмерный вектор ![Формула 11-106 не найдена)[Images/Frml_11_106.jpg); этот вектор неявно определяет θ, величину поворота длины (или величины) r. В результате можно преобразовать ось величин представления до матрицы поворота R следующим образом:

![Формула 11-107 не найдена)[Images/Frml_11_107.jpg)

Так же возможно произвести обратную операцию (перейти от матрицы поворота к оси величин представления) следующим образом:

![Формула 11-108 не найдена)[Images/Frml_11_108.jpg)

Таким образом, все сводится к ситуации, в которой имеется одно представление (представление матрицы), которое наиболее удобно использовать для расчетов, и ещё одно представление (представление Rodrigues), которое немного проще для восприятия мозгом. OpenCV предоставляет две функции для преобразования из любого представления в любое другое представление.

```cpp
void cvRodrigues2(
	 const CvMat* 	src
	,CvMat* 		dst
	,CvMat* 		jacobian = NULL
);
```

Например, имеется вектор r и соответствующее необходимое представление матрицы вращения R; *src* будет соответствовать вектору r размера 3x1, а *dst* матрице вращения R. При этом значения *src* и *dst* можно поменять местами. В любом случае, *cvRodrigues2()* предоставит верный результат. Последний аргумент необязателен. Если *jacobian != NULL*, то это должен быть указатель на матрицу размера 3x9 или 9x3, которая будет заполнена частными производными компонентов конечного массива по отношению к компонентам исходного массива. Выходной аргумент *jacobian* в основном используется для внутренних алгоритмов оптимизации в *cvFindExtrinsicCameraParameters2()* и *cvCalibrateCamera2()*; в основном использование данного параметры ограничивается преобразованием выходов cvFindExtrinsicCameraParameters2()* и *cvCalibrateCamera2()* из векторов Rodrigues ось-угол размера 1x3 или 3x1 в матрицы вращения. Для этого, необходимо просто оставить *jacobian = NULL*.