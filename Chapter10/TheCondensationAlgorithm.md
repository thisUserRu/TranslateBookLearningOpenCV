## [П]|[РС]|(РП) Алгоритм условно плотного распространения

Модели фильтра Kalman могут иметь только одно предположение. Из-за того, что базовая модель распределения вероятности является унимодальной гауссианой, нельзя представить несколько предположений одновременно при использовании фильтра Kalman. Несколько более расширенный метод, известный как *алгоритм condensation* (**Cond**itional **Dens**ity Propag**ation** - условно плотное распространение), основанный на широком классе оценок именуемых *фильтром particles*, позволит преодолеть данную проблему.

Для осознания назначения алгоритма условно плотного распространения, необходимо рассмотреть предположение, что объект движется с постоянной скоростью. Любые измеренные данные, по существу, должны быть интегрированы в модель, как если бы эта модель поддерживала данное предположение. Теперь пусть имеется объект, двигающийся по траектории с преградами. Для этого случая не известно, что объект делает; он может двигаться с постоянной скоростью, может остановиться и/или двигаться в противоположном направлении. Фильтр Kalman не может быть представлен этими несколькими вероятностями, просто расширив неопределенность, связанную с (гауссиана) распределением положений объекта. Фильтр Kalmana – это обязательно гауссиана, поэтому он не может быть представлен мультмодальными распределениями.

Как и в случае с фильтром Kalman имеется две функции для создания и уничтожения структуры данных, используемой в фильтре *condensation*. Разница между этими функциями заключается в том, что в случае функции создания *cvCreateConDensation()* имеется дополнительный параметр. Введенное значение для этого параметра задает число предположений, которые фильтр будет поддерживать в любой момент времени. Это число должно быть достаточно большим (50 или 100; возможно и больше для более сложных случаев), т.к. набор отдельных предположений занимает место в параметризованном распределении вероятности Гаусса фильтра Kalman (Рисунок 10-20).

![Рисунок 10-20 не найден](Images/Pic_10_20.jpg)

Рисунок 10-20. Распределение, которое может (a) и не может (b) быть представлено в виде непрерывного параметризованного распределения Гаусса со значениями среднего и неопределенности; оба распределения в качестве альтернативы могут быть представлены набором *particles*, плотность которых приблизительно соответствует представленному распределению

```cpp
	CvConDensation* cvCreateConDensation(
		 int 	dynam_params
		,int 	measure_params
		,int 	sample_count
	);

	void cvReleaseConDensation(
	 	CvConDensation** 	condens
	);
```

Структура данных *CvConDensation* имеет следующие внутренние элементы:

```cpp
	typedef struct CvConDensation
	{
		int 			MP; 			// Размерность вектора измерений
		int 			DP; 			// Размерность вектора состояния
		float* 			DynamMatr; 		// Матрица линейной динамики системы
		float* 			State; 			// Вектор состояния
		int 			SamplesNum; 	// Число образцов
		float** 		flSamples; 		// массив векторов-образцов
		float** 		flNewSamples; 	// временный массив векторов-образцов
		float* 			flConfidence; 	// Confidence для каждого образца
		float* 			flCumulative; 	// Cumulative confidence
		float* 			Temp; 			// Временный вектор
		float* 			RandomSample; 	// RandomVector для обновления образца
		CvRandState* 	RandS; 			// массив структур, генерируемый случайными векторами
	} CvConDensation;
```

После выделения памяти под структуру данных фильтра *condensation* необходимо инициализировать эту структуру. Это делается за счет использования функции *cvConDensInitSampleSet()*. При создании структуры *CvConDensation* указывается количество *particles*, плюс для каждого *particle* размерность. Инициализация всех этих *particle* может быть довольно таки хлопотным занятием. К счастью для всего этого есть функция *cvConDensInitSampleSet()*; нужно только указать диапазоны для каждой размерности.

```cpp
	void cvConDensInitSampleSet(
		 CvConDensation* 	condens
		,CvMat* 			lower_bound
		,CvMat* 			upper_bound
	);
```

Данная функция запрашивает две ранее проинициализированные структуры *CvMat*. Обе переменные являются векторами (т.е. матрица с одним столбцом) и имеют записи, количество которых равно размерности системы состояния. Эти вектора используются для установки диапазонов, которые в последующем будут задействованы при инициализации векторов образцов в структуре *CvConDensation*.

Ниже представленный код создает две матрицы размером *Dim* и инициализирует их значениями -1 и +1, соответственно. При вызове *cvConDensInitSampleSet()* первоначальные образцы инициализируются случайными числами, каждое из которых находится в пределах от -1 до +1. Таким образом, если *Dim = 3*, то фильтр будет проинициализирован *particles*, равномерно распределенными внутри куба с центром в нуле и со сторонами длинною 2.

```cpp
	CvMat LB = cvMat(Dim,1,CV_MAT32F,NULL);
	CvMat UB = cvMat(Dim,1,CV_MAT32F,NULL);
	cvmAlloc(&LB);
	cvmAlloc(&UB);
	ConDens = cvCreateConDensation(Dim, Dim,SamplesNum);

	for( int i = 0; i<Dim; i++) {
		LB.data.fl[i] = -1.0f;
		UB.data.fl[i] = 1.0f;
	}
	cvConDensInitSampleSet(ConDens,&LB,&UB);
```

И в заключении следующая функция позволяет обновить состояние фильтра *condensation*:

```cpp
	void cvConDensUpdateByTime( CvConDensation* condens );
```

Эта функция делает немного больше, чем может показаться на первый взгляд. В частности необходимо обновлять *confidences* всех *particles* в свете того, что новая информация становиться доступной после предыдущего обновления. К сожалению, в OpenCV удобной функции для этого не предусмотрено. Причина в том, что отношение между новым *confidence* для *particle* и новой информацией зависит от контекста. Пример обновления, который просто применяет обновление *confidence* для каждой *particle*, представлен далее:

```cpp
	// Обновление confidences всех particles в фильтре
	// на основе нового измерения M[], где M имеет размерность
	// particles в фильтре
	//
	void CondProbDens( CvConDensation* CD, float* M ) {
		for( int i=0; i<CD->SamplesNum; i++ ) {
			float p = 1.0f;
			for( int j=0; j<CD->DP; j++ ) {
				p *= (float) exp( -0.05*(M[j] - CD->flSamples[i][j])*(M[j] - CD->flSamples[i][j]) );
			}
			CD->flConfidence[i] = Prob;
		}
	}
```

После обновления *confidences* можно вызывать *cvCondensUpdateByTime()* для обновления *particles*. Термин "обновление" означает *передискретизацию*, которая должна сообщить, что новый набор *particles* будет сгенерирован в соответствии с рассчитанными *confidences*. После обновления все *confidences* вновь будут установлены в *1.0f*, однако, распределение *particles* теперь будет включать ранее модифицированные *confidences* непосредственно в плотности *particles* на следующей итерации.