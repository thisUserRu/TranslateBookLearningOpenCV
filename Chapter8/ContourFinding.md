## (П]|(РС)|(РП) Поиск контуров

Теперь настало время поговорить о *контурах*. Для начала необходимо дать точное определение тому, что такое контур. Контур – это список точек, которые в той или иной форме представляют кривую на изображении. Это представление может быть различным в зависимости от обстоятельств. Есть множество способов для представления кривой. В OpenCV контуры представлены последовательностями, в которых каждая запись содержит информацию о нахождении следующей точки кривой. Чуть позже будут рассмотрены детали, а сейчас достаточно понимать, что контур в OpenCV представлен последовательностью *CvSeq*, которая, так или иначе, является последовательностью точек.

Функция *cvFindContours()* вычисляет контуры из бинарных изображений. Она может принимать изображения, созданные при помощи *cvCanny()*, которые имеют граничные пиксели или изображения, созданные при помощи *cvThreshold()* или *cvAdaptiveThreshold()*, у которых края представлены в виде границы между положительными и отрицательными регионами.

Перед переходом к прототипу функции, необходимо осознать, что такое контур. При разборе работы функции будет введено понятие дерево контура для понимания того, что функция *cvFindContours()* будет возвращать в качестве результата.

На рисунке 8-2 показана функциональность функции *cvFindContours()*. В верхней части рисунка находится тестовое изображение, содержащее несколько белых регионов (обозначены от *A* до *E*) на тёмном фоне. (Для ясности на рисунке тёмные области изображены серым, так проще представить, что изображение подвергнуто пороговому преобразованию, так что серые области устанавливаются в черный цвет только при передачи в функцию *cvFindContours()*). В нижней части рисунка находится тоже изображение, но уже с выделенными контурами, которые обозначены *cX* или *hX*, где "c" расшифровывается как "contour" (контур), "h" расшифровывается как "hole" (отверстие), а "X" это некое число. Некоторые из этих контуров нарисованы пунктирной линией; они представляют *внешние границы* белых регионов (т.е. ненулевых регионов). OpenCV и *cvFindContours()* различают эти внешние границы и пунктирные линии, которые можно представить как *внутренние границы* или как внешние границы *отверстий* (т.е. нулевых регионов).

![Риснуок 8-2 не найден](Images/Pic_8_2.jpg)

Рисунок 8-2. Тестовое изображение (сверху) переданное cvFindContours() (снизу): найденные контуры могут быть одного из двух типов, внешние контуры (штриховые линии) или отверстия (пунктирные линии)

Концепция вложенности играет важную роль во многих приложениях. По этой причине OpenCV может собрать найденные контуры в *дерево контуров*, которое отражает отношение вложенности контуров в своей структуре. Дерево контуров для тестового изображения будет иметь контур *c0* как корневой узел, с отверстиями *h00* и *h01* в качестве потомков. Эти отверстия в свою очередь так же могут иметь потомков и т.д.

	Последствия использования *cvFindContours()* на изображении, генерируемое *cvCanny()* или аналогичными детекторами краев, относительны к бинарному изображению, такому как тестовое изображение на рисунке 8-1. На самом деле *cvFindContours()* ничего не знает о контурах. Это означает, что для *cvFindConours()* "край" это просто очено тонкая "белая" область. В результате для каждого внешнего контура имеется почти точно совпадающий внутренний контур. На самом деле этот внутренний контур просто находится внутри внешней границы. Можно думать об этом как о переходе от белого к черному, который отмечает внутренний край края. 

Теперь пришло время перейти к рассмотрению самой функции *cvFindContours()*: выяснить как передать ей то что нужно и как интерпритировать результаты.

```cpp
	int cvFindContours(
		 IplImage* 					img
		,CvMemStorage* 				storage
		,CvSeq** 					firstContour
		,int 						headerSize = sizeof(CvContour)
		,CvContourRetrievalMode 	mode = CV_RETR_LIST
		,CvChainApproxMethod 		method = CV_CHAIN_APPROX_SIMPLE
	);
```

Первый аргумент - это исходное изображение; оно должно быть 8-ми битным одно-канальным изображением и интерпритироватья как бинарное (т.е. все ненулевые пиксели должны быть эквивалентны друг к другу). После запуска процесса вычмслений, функция *cvFindContours()* использует это изображение как рабочее пространство, поэтому, если необходимо иметь неизмененное исходное изображение, то в функцию необходимо передать копию изображения. Следующий аргумент *storage* указывает место, где функция может найти память для сохранения контуров. Это хранилище должно быть создано с помощью функции *cvCreatememStorage()*. Следующий аргумент *firstContour* является указателем на *CvSeq**. Функция *cvFindContours()* сама инициализирует этот указатель. Поэтому достаточно только передать указатель на указатель. Операции выделения/удаления (*new/delete* или *malloc/free*) не нужны. Именно этот аргумент (*firstContour*) является указателем на корень дерева контуров. (Деревья контуров являются лишь одним из способ организации найденных контуров. В любом случае они будут организованы с помощью элементво контуров *CV_TREE_NODE_FIELDS*, про которые шла речь в самом начале знакомства с последовательностями). Функция возвращает общее количесвто найденных контуров. 

```cpp
	vSeq* firstContour = NULL;
	cvFindContours( ..., &firstContour, ... );
```

Аргумент *headerSize* сообщает *cvFindContours()* о размерах объктов, которые функция будет создавать; он может быть установлен в *sizeof(CvContour)* или в *sizeof(CvChain)* (последний используется при установленном методе аппроксимации в *CV_CHAIN_CODE*). (Фактически *headerSize* может быть любым числом, которое больше или равно перечисленным значениям). И в заключении, аргументы *mode* и *method* уточняют что должно быть вычислено и как (соответственно).

Аргумент *mode* может быть установлен в одно из следующих значений: *CV_RETR_EXTERNAL*, *CV_RETR_LIST*, *CV_RETR_CCOMP* или *CV_RETR_TREE*. Значение *mode* указывает *cvFindContours()* какие контуры необходимо найти и в каком виде необходимо получить результат. В частности, способ использования переменных узлов дерева (*h_prev*, *h_next*, *v_prev* и *v_next*) для "соединения" найденных контуров определяется значением *mode*. Рисунок 8-3 отображает результирующие топологии для всех четырех возможных значений *mode*. В каждом из случаев, структуры могут рассматриваться как "уровни", которые связаны "горизонтальными" связями (*h_next* и *h_prev*) и отделены друг от друга *вертикальными* связями (*v_next* и *v_prev*).

![Рисунок 8-3 не найден](Images/Pic_8_3.jpg)

Рисунок 8-3. Способы соединения переменных вершин дерева, найденных *cvFindContours()*

*CV_RETR_EXTERNAL*
	
Извлечение только крайних внешних контуров. На рисунке 8-2 есть только один внешний контур, поэтому на рисунке 8-3 показаны точки только первого контура внешней последовательности, не имеющей никаких дальнейших связей.

*CV_RETR_LIST*
	
Извлечение всех контуров и размещение их в списке. Рисунок 8-3 отображает список, полученный в результате обработки тестового изображения с рисунка 8-2. В этом случае найдено восемь контуров, и все они связаны друг с другом *h_prev* и *h_next* (*v_prev* и *v_next* не используются).

*CV_RETR_CCOMP*
	
Извлечение всех контуров и организация их в двухуровневую иерархию, где границы верхнего уровня являются внешними границами компонентов, а границы второго уровня являются границами отверстий. По рисунку 8-3 можно видеть, что есть пять внешних границ, три из которых содержат отверстия. Отверстия связаны с соответствующими внешними границами при помощи *v_prev* и *v_next*. Внешняя граница *c0* содержит два отверстия. Т.к. *v_next* может содержать только одно значение, то узел может иметь только одного наследника. Все отверстия внутри *c0* связаны друг с другом указателями *h_prev* и *h_next*.

*CV_RETR_TREE*

Извлечение всех контуров и восстановление полной иерархии вложенных контуров. В рассматриваемом примере (рисунок 8-2 и 8-3) это означает, что корневой узел является внешним контуром *c0*. Следом за *c0* идет отверстие *h00*, соединенное с другим отверстием *h01* на том же уровне. Каждое из этих отверстий в свою очередь имеет наследников (контуры *c000* и *c001* соответственно), которые связаны с их родителями вертикальными связями. Так продолжается вниз по иерархии вплоть до самых внутренних контуров изображения, которые становятся листьями деревьев. 

Следующие пять флагов относятся к *method* (т.е. каким образом контуры аппроксимируются).

*CV_CHAIN_CODE*

Внешние контуры в виде кодовой цепочки Фримана; все другие методы выводят полигоны (последовательности вершин)

*CV_CHAIN_APPROX_NONE*

Перевод кодовой цепочки в точки.

*CV_CHAIN_APPROX_SIMPLE*

Сжатие горизонтальных, вертикальных и диагональных сегментов, оставляя только их угловые точки.

*CV_CHAIN_APPROX_TC89_L1* или *CV_CHAIN_APPROX_TC89_KCOS*

Применение одной из разновидностей алгоритма аппроксимации цепочек Teh-Chin.

*CV_LINK_RUNS*

Комплексный дифференциальный алгоритм (один из выше перечисленных), который связывает горизонтальные сегменты 1s.

### Контуры последовательности

Существует огромное количество различных контуров и последовательностей. Хорошая новость в том, что для текущих задач потребуется небольшое количество из них. В результате вызова *cvFindContours()* получается довольно таки много различных последовательностей. Все эти последовательности имеют один конкретный тип; тип зависит от аргументов, передаваемых в *cvFindContours()*. По умолчанию используется режим *CV_RETR_LIST* и метод *CV_CHAIN_APPROX_SIMPLE*.

Эти последовательности являются последовательностями точек; точнее контурами. Главное, что нужно помнить о контурах – это частный случай последовательности. (Тип *CvContour* не совпадает с *CvSeq*. По сути *CvContour* унаследован от *CvSeq* и имеет несколько дополнительных членов, а именно цвет *color* и ограничительную рамку типа *CvRect*). Контур – это последовательность точек, представляющая некую кривую в пространстве. Такие цепочки точек встречаются довольно таки часто, так что существуют специальные функции, помогающие манипулировать ими. 

```cpp
	int cvFindContours(
		 CvArr* 		image
		,CvMemStorage* 	storage
		,CvSeq** 		first_contour
		,int 			header_size = sizeof(CvContour)
		,int 			mode = CV_RETR_LIST
		,int 			method = CV_CHAIN_APPROX_SIMPLE
		,CvPoint 		offset = cvPoint(0,0)
	);

	CvContourScanner cvStartFindContours(
		 CvArr* 		image
		,CvMemStorage* 	storage
		,int 			header_size = sizeof(CvContour)
		,int 			mode = CV_RETR_LIST
		,int 			method = CV_CHAIN_APPROX_SIMPLE
		,CvPoint 		offset = cvPoint(0,0)
	);

	CvSeq* cvFindNextContour(
	 	CvContourScanner 	scanner
	);
	 
	void cvSubstituteContour(
		 CvContourScanner 	scanner
		,CvSeq* 			new_contour
	);
	 
	CvSeq* cvEndFindContour(
	 	CvContourScanner* 	scanner
	);
	 
	CvSeq* cvApproxChains(
		 CvSeq* 			src_seq
		,CvMemStorage* 		storage
		,int 				method = CV_CHAIN_APPROX_SIMPLE
		,double 			parameter = 0
		,int 				minimal_perimeter = 0
		,int 				recursive = 0
	);
```

Первую функцию *cvFindContours()* уже доводилось видеть ранее. Вторая функция *cvStartFindContours()* тесно связана с *cvFindContours()* и используется, если необходимо обрабатывать контуры по одному, в то время как они упакованы в более высокоуровневую структуру. Функция *cvStartFindContours()* возвращает *cvSequenceScanner*. Сканер содержит информацию о том, что может быть прочитано, а что нет. (Важно не путать *CvSequenceScanner* с *CvSeqReader*. Последний используется для чтения элементов последовательности, в то время, как *CvSequenceScanner* используется для чтения того, что по сути является списком последовательностей). В последующем можно вызвать *cvFindNextContour()* и последовательно получить все найденные контуры. Если вернется NULL, то это будет означать, что контуров больше не осталось.

Функция *cvSubstituteContour()* позволяет заменять контур, на который в данный момент указывает сканер на какой-либо другой контур. Полезной особенностью этой функции является то, что если *new_contour = NULL*, то текущий контур будет удален из цепи или дерева, на который указывает сканер (последовательность будет обновлена соответствующим образом, так что не будет указателей на несуществующие объекты).

И в заключении, функция *cvEndFindContour()* завершает сканирование и устанавливает сканер в состояние «выполнено». При этом сканируемая последовательность не удаляется; на самом деле, значение, возвращаемое * cvEndFindContour()* является указателем на первый элемент последовательности.

Функция *cvApproxChains()* преобразует коды Фримена к полигональному представлению (точно или с некоторым приближением). Более подробно данная функция будет рассмотрена далее в этой главе (раздел «Полигон приближения»).

### Цепной код Фримена

