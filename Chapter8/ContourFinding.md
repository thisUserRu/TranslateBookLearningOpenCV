## (П]|(РС)|(РП) Поиск контуров

Теперь настало время поговорить о *контурах*. Для начала необходимо дать точное определение тому, что такое контур. Контур – это список точек, которые в той или иной форме представляют кривую на изображении. Это представление может быть различным в зависимости от обстоятельств. Есть множество способов для представления кривой. В OpenCV контуры представлены последовательностями, в которых каждая запись содержит информацию о нахождении следующей точки кривой. Чуть позже будут рассмотрены детали, а сейчас достаточно понимать, что контур в OpenCV представлен последовательностью *CvSeq*, которая, так или иначе, является последовательностью точек.

Функция *cvFindContours()* вычисляет контуры из бинарных изображений. Она может принимать изображения, созданные при помощи *cvCanny()*, которые имеют граничные пиксели или изображения, созданные при помощи *cvThreshold()* или *cvAdaptiveThreshold()*, у которых края представлены в виде границы между положительными и отрицательными регионами.

Перед переходом к прототипу функции, необходимо осознать, что такое контур. При разборе работы функции будет введено понятие дерево контура для понимания того, что функция *cvFindContours()* будет возвращать в качестве результата.

На рисунке 8-2 показана функциональность функции *cvFindContours()*. В верхней части рисунка находится тестовое изображение, содержащее несколько белых регионов (обозначены от *A* до *E*) на тёмном фоне. (Для ясности на рисунке тёмные области изображены серым, так проще представить, что изображение подвергнуто пороговому преобразованию, так что серые области устанавливаются в черный цвет только при передачи в функцию *cvFindContours()*). В нижней части рисунка находится тоже изображение, но уже с выделенными контурами, которые обозначены *cX* или *hX*, где "c" расшифровывается как "contour" (контур), "h" расшифровывается как "hole" (отверстие), а "X" это некое число. Некоторые из этих контуров нарисованы пунктирной линией; они представляют *внешние границы* белых регионов (т.е. ненулевых регионов). OpenCV и *cvFindContours()* различают эти внешние границы и пунктирные линии, которые можно представить как *внутренние границы* или как внешние границы *отверстий* (т.е. нулевых регионов).

![Риснуок 8-2 не найден](Images/Pic_8_2.jpg)

Рисунок 8-2. Тестовое изображение (сверху) переданное cvFindContours() (снизу): найденные контуры могут быть одного из двух типов, внешние контуры (штриховые линии) или отверстия (пунктирные линии)

Концепция вложенности играет важную роль во многих приложениях. По этой причине OpenCV может собрать найденные контуры в *дерево контуров*, которое отражает отношение вложенности контуров в своей структуре. Дерево контуров для тестового изображения будет иметь контур *c0* как корневой узел, с отверстиями *h00* и *h01* в качестве потомков. Эти отверстия в свою очередь так же могут иметь потомков и т.д.

	Последствия использования *cvFindContours()* на изображении, генерируемое *cvCanny()* или аналогичными детекторами краев, относительны к бинарному изображению, такому как тестовое изображение на рисунке 8-1. На самом деле *cvFindContours()* ничего не знает о контурах. Это означает, что для *cvFindConours()* "край" это просто очено тонкая "белая" область. В результате для каждого внешнего контура имеется почти точно совпадающий внутренний контур. На самом деле этот внутренний контур просто находится внутри внешней границы. Можно думать об этом как о переходе от белого к черному, который отмечает внутренний край края. 

Теперь пришло время перейти к рассмотрению самой функции *cvFindContours()*: выяснить как передать ей то что нужно и как интерпритировать результаты.

```cpp
	int cvFindContours(
		 IplImage* 					img
		,CvMemStorage* 				storage
		,CvSeq** 					firstContour
		,int 						headerSize = sizeof(CvContour)
		,CvContourRetrievalMode 	mode = CV_RETR_LIST
		,CvChainApproxMethod 		method = CV_CHAIN_APPROX_SIMPLE
	);
```

Первый аргумент - это исходное изображение; оно должно быть 8-ми битным одно-канальным изображением и интерпритироватья как бинарное (т.е. все ненулевые пиксели должны быть эквивалентны друг к другу). После запуска процесса вычмслений, функция *cvFindContours()* использует это изображение как рабочее пространство, поэтому, если необходимо иметь неизмененное исходное изображение, то в функцию необходимо передать копию изображения. Следующий аргумент *storage* указывает место, где функция может найти память для сохранения контуров. Это хранилище должно быть создано с помощью функции *cvCreatememStorage()*. Следующий аргумент *firstContour* является указателем на *CvSeq**. Функция *cvFindContours()* сама инициализирует этот указатель. Поэтому достаточно только передать указатель на указатель. Операции выделения/удаления (*new/delete* или *malloc/free*) не нужны. Именно этот аргумент (*firstContour*) является указателем на корень дерева контуров. (Деревья контуров являются лишь одним из способ организации найденных контуров. В любом случае они будут организованы с помощью элементво контуров *CV_TREE_NODE_FIELDS*, про которые шла речь в самом начале знакомства с последовательностями). Функция возвращает общее количесвто найденных контуров. 

```cpp
	vSeq* firstContour = NULL;
	cvFindContours( ..., &firstContour, ... );
```

Аргумент *headerSize* сообщает *cvFindContours()* о размерах объктов, которые функция будет создавать; он может быть установлен в *sizeof(CvContour)* или в *sizeof(CvChain)* (последний используется при установленном методе аппроксимации в *CV_CHAIN_CODE*). (Фактически *headerSize* может быть любым числом, которое больше или равно перечисленным значениям). И в заключении, аргументы *mode* и *method* уточняют что должно быть вычислено и как (соответственно).

Аргумент *mode* может быть установлен в одно из следующих значений: *CV_RETR_EXTERNAL*, *CV_RETR_LIST*, *CV_RETR_CCOMP* или *CV_RETR_TREE*. Значение *mode* указывает *cvFindContours()* какие контуры необходимо найти и в каком виде необходимо получить результат. В частности, способ использования переменных узлов дерева (*h_prev*, *h_next*, *v_prev* и *v_next*) для "соединения" найденных контуров определяется значением *mode*. Рисунок 8-3 отображает результирующие топологии для всех четырех возможных значений *mode*. В каждом из случаев, структуры могут рассматриваться как "уровни", которые связаны "горизонтальными" связями (*h_next* и *h_prev*) и отделены друг от друга *вертикальными* связями (*v_next* и *v_prev*).

![Рисунок 8-3 не найден](Images/Pic_8_3.jpg)

Рисунок 8-3. Способы соединения переменных вершин дерева, найденных *cvFindContours()*

*CV_RETR_EXTERNAL*
	
Извлечение только крайних внешних контуров. На рисунке 8-2 есть только один внешний контур, поэтому на рисунке 8-3 показаны точки только первого контура внешней последовательности, не имеющей никаких дальнейших связей.

*CV_RETR_LIST*
	
Извлечение всех контуров и размещение их в списке. Рисунок 8-3 отображает список, полученный в результате обработки тестового изображения с рисунка 8-2. В этом случае найдено восемь контуров, и все они связаны друг с другом *h_prev* и *h_next* (*v_prev* и *v_next* не используются).

*CV_RETR_CCOMP*
	
Извлечение всех контуров и организация их в двухуровневую иерархию, где границы верхнего уровня являются внешними границами компонентов, а границы второго уровня являются границами отверстий. По рисунку 8-3 можно видеть, что есть пять внешних границ, три из которых содержат отверстия. Отверстия связаны с соответствующими внешними границами при помощи *v_prev* и *v_next*. Внешняя граница *c0* содержит два отверстия. Т.к. *v_next* может содержать только одно значение, то узел может иметь только одного наследника. Все отверстия внутри *c0* связаны друг с другом указателями *h_prev* и *h_next*.

*CV_RETR_TREE*

Извлечение всех контуров и восстановление полной иерархии вложенных контуров. В рассматриваемом примере (рисунок 8-2 и 8-3) это означает, что корневой узел является внешним контуром *c0*. Следом за *c0* идет отверстие *h00*, соединенное с другим отверстием *h01* на том же уровне. Каждое из этих отверстий в свою очередь имеет наследников (контуры *c000* и *c001* соответственно), которые связаны с их родителями вертикальными связями. Так продолжается вниз по иерархии вплоть до самых внутренних контуров изображения, которые становятся листьями деревьев. 

Следующие пять флагов относятся к *method* (т.е. каким образом контуры аппроксимируются).

*CV_CHAIN_CODE*

Внешние контуры в виде кодовой цепочки Фримана; все другие методы выводят полигоны (последовательности вершин)

*CV_CHAIN_APPROX_NONE*

Перевод кодовой цепочки в точки.

*CV_CHAIN_APPROX_SIMPLE*

Сжатие горизонтальных, вертикальных и диагональных сегментов, оставляя только их угловые точки.

*CV_CHAIN_APPROX_TC89_L1* или *CV_CHAIN_APPROX_TC89_KCOS*

Применение одной из разновидностей алгоритма аппроксимации цепочек Teh-Chin.

*CV_LINK_RUNS*

Комплексный дифференциальный алгоритм (один из выше перечисленных), который связывает горизонтальные сегменты 1s.

### Контуры последовательности

Существует огромное количество различных контуров и последовательностей. Хорошая новость в том, что для текущих задач потребуется небольшое количество из них. В результате вызова *cvFindContours()* получается довольно таки много различных последовательностей. Все эти последовательности имеют один конкретный тип; тип зависит от аргументов, передаваемых в *cvFindContours()*. По умолчанию используется режим *CV_RETR_LIST* и метод *CV_CHAIN_APPROX_SIMPLE*.

Эти последовательности являются последовательностями точек; точнее контурами. Главное, что нужно помнить о контурах – это частный случай последовательности. (Тип *CvContour* не совпадает с *CvSeq*. По сути *CvContour* унаследован от *CvSeq* и имеет несколько дополнительных членов, а именно цвет *color* и ограничительную рамку типа *CvRect*). Контур – это последовательность точек, представляющая некую кривую в пространстве. Такие цепочки точек встречаются довольно таки часто, так что существуют специальные функции, помогающие манипулировать ими. 

```cpp
	int cvFindContours(
		 CvArr* 		image
		,CvMemStorage* 	storage
		,CvSeq** 		first_contour
		,int 			header_size = sizeof(CvContour)
		,int 			mode = CV_RETR_LIST
		,int 			method = CV_CHAIN_APPROX_SIMPLE
		,CvPoint 		offset = cvPoint(0,0)
	);

	CvContourScanner cvStartFindContours(
		 CvArr* 		image
		,CvMemStorage* 	storage
		,int 			header_size = sizeof(CvContour)
		,int 			mode = CV_RETR_LIST
		,int 			method = CV_CHAIN_APPROX_SIMPLE
		,CvPoint 		offset = cvPoint(0,0)
	);

	CvSeq* cvFindNextContour(
	 	CvContourScanner 	scanner
	);
	 
	void cvSubstituteContour(
		 CvContourScanner 	scanner
		,CvSeq* 			new_contour
	);
	 
	CvSeq* cvEndFindContour(
	 	CvContourScanner* 	scanner
	);
	 
	CvSeq* cvApproxChains(
		 CvSeq* 			src_seq
		,CvMemStorage* 		storage
		,int 				method = CV_CHAIN_APPROX_SIMPLE
		,double 			parameter = 0
		,int 				minimal_perimeter = 0
		,int 				recursive = 0
	);
```

Первую функцию *cvFindContours()* уже доводилось видеть ранее. Вторая функция *cvStartFindContours()* тесно связана с *cvFindContours()* и используется, если необходимо обрабатывать контуры по одному, в то время как они упакованы в более высокоуровневую структуру. Функция *cvStartFindContours()* возвращает *cvSequenceScanner*. Сканер содержит информацию о том, что может быть прочитано, а что нет. (Важно не путать *CvSequenceScanner* с *CvSeqReader*. Последний используется для чтения элементов последовательности, в то время, как *CvSequenceScanner* используется для чтения того, что по сути является списком последовательностей). В последующем можно вызвать *cvFindNextContour()* и последовательно получить все найденные контуры. Если вернется NULL, то это будет означать, что контуров больше не осталось.

Функция *cvSubstituteContour()* позволяет заменять контур, на который в данный момент указывает сканер на какой-либо другой контур. Полезной особенностью этой функции является то, что если *new_contour = NULL*, то текущий контур будет удален из цепи или дерева, на который указывает сканер (последовательность будет обновлена соответствующим образом, так что не будет указателей на несуществующие объекты).

И в заключении, функция *cvEndFindContour()* завершает сканирование и устанавливает сканер в состояние «выполнено». При этом сканируемая последовательность не удаляется; на самом деле, значение, возвращаемое * cvEndFindContour()* является указателем на первый элемент последовательности.

Функция *cvApproxChains()* преобразует коды Фримена к полигональному представлению (точно или с некоторым приближением). Более подробно данная функция будет рассмотрена далее в этой главе (раздел «Полигон приближения»).

### Цепной код Фримена

Как правило, контуры, созданные при помощи *cvFindContours()* являются последовательностями вершин (т.е. точек). Альтернативное представление может быть получено путем установки *method = CV_CHAIN_CODE*. В этом случае, найденные контуры будут храниться в виде *цепи Фримена* (Рисунок 8-4). Цепь Фримена – это полигон, представляющий последовательность шагов в одном из 8-ми направлений; каждый шаг обозначается целым числом от 0 до 7. При работе с цепями Фримена можно читать их содержимое при помощи двух «вспомогательных» функций:

```cpp
void cvStartReadChainPoints(
 CvChain* 		chain
,CvChainPtReader* 	reader
);

CvPoint cvReadChainPoint(
 CvChainPtReader* 	reader
);
```

![Рисунок 8-4 не найден](Images/Pic_8_4.jpg)

Рисунок 8-4. (a) Направления цепи Фримена, пронумерованные целыми числами 0-7; (b) Контур, конвертируемый в цепь Фримена, начиная с заднего бампера

Первая функция принимает цепь в качестве аргумента, а вторая функция цепь читает. Структура *CvChain* является формой *CvSeq*. *CvChainPtReader* перебирает один контур представленный кодом Фримена, так же как * CvContourScanner* перебирает различные контуры. В связи с этим, итератор * CvChainPtReader* схож с более обобщенным итератором * CvSeqReader*, а * cvStartReadChainPoints* играет роль * cvStartReadSeq*. Как и следовало ожидать, *CvChainPtReader* возвращает NULL, когда читать больше нечего.

### Рисование контуров

Одной из наиболее важных задач является рисование контура на экране. Для этого в OpenCV есть * cvDrawContours()*:

```cpp
void cvDrawContours(
 CvArr* 		img
,CvSeq* 	contour
,CvScalar 	external_color
,CvScalar 	hole_color
,int 		max_level
,int 		thickness 	= 1
,int 		line_type 	= 8
,CvPoint 	offset 		= cvPoint(0,0)
);
```

Первый аргумент – это изображение, на котором будет рисоваться контур. Следующий аргумент *contour* не столь прост, как кажется. В частности он рассматривается как корневой узел дерева контуров. Другие аргументы (в первую очередь *max_level*) определяют, что должно быть сделано с остальной часть дерева. Следующий аргумент довольно прост: цвет, которым будет рисоваться контур. Но что насчёт *hole_color*? Напомним, что OpenCV различает внешние и внутренние контуры (штриховые и пунктирные линии, представленные на рисунке 8-2). При рисовании одного контура или дерева контуров, любой контур помеченные как "отверстие" (внутренний) будет рисоваться этим альтернативным цветом.

Аргумент *max_level* сообщает *cvDrawContours()* как обращаться с любыми контурами, которые могут быть присоединены к *contour* с помощью переменных вершин дерева. Этот аргумент может быть установлен для того, чтобы указать максимальную глубину прохода на рисунке. Таким образом, *max_level = 0* означает, что будут взяты все контуры на том же уровне что и входной уровень (точнее, входной контур и контуры, следующие за ним), *max_level = 1* означает, что будут взяты все контуры и их потомки на том же уровне что и входной, и так далее. Если функция *cvFindContours()* вызывается с аргументом *mode* равным *CV_RETR_CCOMP* или *CV_RETR_TREE*, то *max_level* может иметь отрицательное значение. В этом случае *max_level = -1* означает, что будет нарисован только входной контур, *max_level = -2* означает, что будет нарисован входной контур и его прямой потомок, и так далее. Пример использования можно найти в *…/opencv/samples/c/contours.c*.

Параметры *thickness* и *line_type* имеют свои обычные значения. Можно так же задействовать *offset* для того, чтобы контур был нарисован в другом месте относительно абсолютных координат, по которым он определяется. Эта особенность весьма полезна, когда контур уже был преобразован к системе центр-масса или каким-либо другим локальным координатам.

Аргумент *offset* так же будет полезен, если использовать функцию *cvFindContours()* один или несколько раз в различных регионах изображения (ROIs), с последующим отображением полученных результатов на исходном изображении. В противоположность этому, можно использовать *offset* для извлечения контура из исходного изображения, с последующим созданием небольшой маски для этого контура.

### Пример работы с контуром

Приведенный пример взят из пакета OpenCV. Вначале создается окно с изображением в нем. Ползунок задает значение порога, а контуры рисуются на изображении после порогового преобразования. Конечное изображение обновляется каждый раз при изменении положения ползунка.

Пример 8-2. Поиск контуров на изображение в зависимости от положения ползунка; изображение обновляется при изменении положения ползунка

```cpp
#include <cv.h>
#include <highgui.h>
 
IplImage* g_image = NULL;
IplImage* g_gray = NULL;
int g_thresh = 100;
CvMemStorage* g_storage = NULL;
 
void on_trackbar(int) {
    if( g_storage==NULL ) {
        g_gray = cvCreateImage( cvGetSize(g_image), 8, 1 );
        g_storage = cvCreateMemStorage(0);
    } else {
        cvClearMemStorage( g_storage );
    }
 
    CvSeq* contours = 0;
    cvCvtColor( g_image, g_gray, CV_BGR2GRAY );
    cvThreshold( g_gray, g_gray, g_thresh, 255, CV_THRESH_BINARY );
    cvFindContours( g_gray, g_storage, &contours );
    cvZero( g_gray );
    if( contours )
        cvDrawContours(
            g_gray,
            contours,
            cvScalarAll(255),
            cvScalarAll(255),
            100
        );
    cvShowImage( "Contours", g_gray );
}
 
int main( int argc, char** argv )
{
    if( argc != 2 || !(g_image = cvLoadImage(argv[1])) )
        return -1;
    cvNamedWindow( "Contours", 1 );
    cvCreateTrackbar(
        "Threshold",
        "Contours",
        &g_thresh,255,
        on_trackbar
    );
    on_trackbar(0);
    cvWaitKey();
    return 0;
}
```

Все самое интересное происходит внутри функции *on_trackbar()*. Если глобальная переменная *g_storage* имеет начальное значение (NULL), то * cvCreateMemStorage(0)* создает хранилище памяти, *g_gray* инициализируется пустым изображением того же размера, что и *g_image*, но только с одним каналом. Если *g_storage != NULL*, то хранилище очищается для повторного использования. Далее создается указатель *CvSeq**; он будет указывать на последовательность, созданную при помощи *cvFindContours()*.

Далее *g_image* конвертируется в черно-белое и подвергается пороговому преобразованию: все пиксели, которые ярче *g_thresh* сохраняют ненулевые значения. Функция *cvFindContours()* применяется к изображению, прошедшее пороговое преобразование. Если контуры были найдены (т.е. если *contours != NULL*), тогда функция * cvDrawContours()* рисует (белые) контуры на сером изображении. В завершении, изображение отображается на экране, а память под структуры, выделенная в начале обратного вызова, освобождается. 

