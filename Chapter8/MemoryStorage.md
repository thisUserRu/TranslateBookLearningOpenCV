## [П]|[РС]|(РП) Хранилище памяти

OpenCV использует объект именуемый **memory storage** (хранилище памяти) в качестве метода управления выделением памяти для динамического объекта. *Memory storage* - это связанные списки блоков памяти, которые допускают быстрое распределение и перераспределение непрерывного набора блоков. Функции OpenCV, требующие выделение памяти для их нормального функционирования запрашивают доступ к *memory storage*, благодаря которому можно получить необходимую память (как правило, это функции, результаты которых имеют переменный размер)

*Memory storage* обрабатывается следующими четырьмя функциями:

```cpp
CvMemStorage* cvCreateMemStorage(
 int block_size = 0
);
void cvReleaseMemStorage(
 CvMemStorage** storage
);
void cvClearMemStorage(
 CvMemStorage* storage
);
void* cvMemStorageAlloc(
 CvMemStorage* storage
,size_t size
);
```

Для создания *memory storage* используется функция *cvCreateMemStorage()*. В качестве исходных значений функции передается размер блока, который устанавливает размер блока памяти в хранилище. Если этот аргумент установлен в 0, тогда по умолчанию будет использован блок размера 64kB. Функция возвращает указатель нового хранилища памяти.

Функция *cvReleaseMemStorage()* использует указатель хранилища памяти для освобождения занимаемой памяти. Это, по сути, соответствует освобождению изображений, матриц и других структур.

Для освобождения памяти так же можно воспользоваться *cvClearMemStorage()*, которая тоже принимает указатель на существующее хранилище. Однако необходимо знать одну особенность этой функции: это единственный способ освободить (для повторного использования этого хранилища) память, выделенную под хранилище. Это может показаться не столь важным, но есть процедуры, которые удаляют объекты внутри хранилища, а занимаемую память не освобождают. Короче говоря, только *cvClearMemStorage()* (и, конечно, *cvReleaseMemStorage()*) могут освобождать занимаемую память. (На самом деле функция * cvRestoreMemStoragePos()* может восстановить память в хранилище. Однако эта функция, прежде всего для внутреннего пользования библиотеки и выходит за рамки данной книги). Удаление любой динамической структуры (*CvSeq*, *CvSet* и т.д.) никогда не возвращает память обратно в хранилище (хотя структуры в состоянии снова использовать память, однажды взятую из хранилища под собственные данные).

Так же возможно выделение собственных блоков из хранилища при помощи функции *cvMemStorageAlloc()* по аналогии с тем, как *malloc()* выделяет память из кучи. В этом случае необходимо будет указать лишь указатель на хранилище и число требуемых байтов. Функция возвратит указатель типа *void** (подобно *malloc()*).