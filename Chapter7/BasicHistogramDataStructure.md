## [П]|[РС]|(РП) Базовый тип Histogram

Для начала необходимо разобраться со структурой *CvHistogram*:

```cpp
	typedef struct CvHistogram
	{
		int 		type;
		CvArr* 		bins;
		float 		thresh[CV_MAX_DIM][2]; 	// для однородных гистограмм
		float** 	thresh2; 				// для неоднородных гистограмм
		CvMatND 	mat; 					// встроенный заголовок матрицы
		                 					// для массива гистограмм
	}
	CvHistogram;
```

Данное объявление обманчиво простое, потому что большая часть внутренних данных гистограммы храниться внутри структуры *CvMatND*. Создать гистограмму можно при помощи следующей функции:

```cpp
	CvHistogram* cvCreateHist(
		 int 		dims
		,int* 		sizes
		,int 		type
		,float** 	ranges = NULL
		,int 		uniform = 1
	);
```

Аргумент *dims* задает размерность гистограммы. Аргумент *sizes* должен быть массивом целых чисел размера *dims*. Каждое целое число в этом массиве задает то, какое количество контейнеров должно быть отнесено к соответствующей размерности. Аргумент *type* может быть либо *CV_HIST_ARRAY* для многомерных гистограмм, хранящиеся с использованием плотной многомерной матричной структуры (т.е. *CvMatND*), либо *CV_HIST_SPARSE* (от старых версий осталась поддержка *CV_HIST_TREE*, идентичная *CV_HIST_SPARSE*), если данные будут храниться с помощью разряженных матриц представления (*CvSparseMat*). Аргумент *ranges* может принимать одну из двух форм. Для однородных гистограмм, *ranges* - массив пар (эти "пары" всего лишь C-массивы с двумя записями) значений с плавающей точкой, где число пар равно размерности. Для неоднородных гистограмм, пары, использующиеся для однородных гистограмм, заменяются массивами, содержащие значения, разделенные неоднородными контейнерами. Если имеется N контейнеров, тогда в каждом из этих подмассивов будет N+1 записей. Каждый массив значений начинается от нижней границе первого контейнера и заканчивается верхней границей последнего (Для уточнения: в случае однородной гистограммы, если нижний и верхний диапазоны установлены в 0 и 10 соответственно и если есть два контейнера, то контейнерам будут назначены соответствующие интервалы [0, 5) и [5, 10]. В случае неоднородной гистограммы, если размерность равна 4 и если есть соответствующие диапазоны значений (0, 2, 4, 9, 10), то контейнерам будут назначены следующие (неоднородные) интервалы: [0, 2), [2,4), [4, 9) и [9, 10]). Аргумент *uniform* указывает на то, должны ли у гистограммы быть однородные контейнеры и таким образом указывать как будут интерпретироваться диапазоны значений; если установлено значение отличное от нуля, контейнеры будут однородными (при этом не стоит обращать внимание на то, что этот аргумент имеет тип int). Существует возможность устанавливать аргумент *ranges* в NULL, в этом случае диапазон просто будет "неизвестен" (можно будет установить потом при помощи *cvSetHistBinRanges()*). Должно быть очевидно, что значения диапазона необходимо задавать перед использованием гистограмм.

```cpp
	void cvSetHistBinRanges(
		 CvHistogram* 	hist
		,float** 		ranges
		,int 			uniform = 1
	);
```

Аргументы *cvSetHistRanges()* в точности совпадают с аргументами *cvCreateHist()*. После того, как гистограмма создана, её можно очистить (т.е. установить все контейнеры в 0):

```cpp
	void cvClearHist(
		CvHistogram* 	hist
	);
```

Чтобы освободить память, которую занимает гистограмма можно воспользоваться функцией: 

```cpp
	void cvReleaseHist(
		CvHistogram** 	hist
	);
```

Как и всегда, для вызова подобного рода функций передается двойной указатель на объект. После освобождения памяти, указатель на гистограмму устанавливается в NULL.

Есть еще одна полезная функция, которая позволяет создавать гистограммы из уже существующих данных:

```cpp
	CvHistogram* cvMakeHistHeaderForArray(
		 int 			dims
		,int* 			sizes
		,CvHistogram* 	hist
		,float* 		data
		,float** 		ranges = NULL
		,int 			uniform = 1
	);
```

В этом случае *hist* является указателем на структуру *CvHistogram*, а *data* указателем на область размером *sizes[0]×sizes[1]×...×sizes[dims-1]* для хранения контейнеров. *data* это указатель на float, т.к. внутреннее представление данных в гистограмме имеет тип float. Возвращаемое значение это одно из значений *hist*. В отличие от *cvCreateHist()*, данная функция не имеет аргумента *type*. Все гистограммы, созданные при помощи *cvMakeHistHeaderForArray()*, являются плотными гистограммами. И в заключение: так, как, скорее всего, разработчик сам будет выделять пространство под *data* для хранения контейнеров, не будет происходить вызов функции *cvReleaseHist()* внутри структуры *CvHistogram*. И потому, разработчик должен сам позаботиться об очистке заголовка структуры (если она не была размещена в стеке) и данных.
