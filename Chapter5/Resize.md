## [П]|[РС]|(РП) Изменение размера

Зачастую приходиться обрабатывать изображения неподходящего размера. Поэтому возникает потребность в функции, которая могла бы уменьшать или увеличивать исходное изображение. Для решения подобного рода задач в OpenCV есть функция *cvResize()*. Эта функция подгоняет исходное изображение под конечное изображение. Если задан ROI (регион интереса) на исходном изображении, то оно будет промасштабировано и подогнано под конечное изображение. Точно также, если в конечном изображении установлен ROI, тогда исходное изображении будет перемасштабировано под размеры этого региона. 

```cpp
void cvResize(
     const CvArr*   src
    ,CvArr*         dst
    ,int            interpolation = CV_INTER_LINER
);
```

Последний аргумент - это метод интерполяции (по умолчанию - линейная интерполяция). Другие доступные опции показаны в Таблице 5-4. 

Таблица 5-4. Опции интерполяции

| Интерполяция | Значение |
| -- | -- |
| CV_INTER_NN | Ближайшие соседи |
| CV_INTER_LINEAR | Билинейная |
| CV_INTER_AREA | re-sampling по области пикселя |
| CV_INTER_CUBIC | Бикубическая |

В общем случае требуется получить наиболее сглаженное преобразование исходного изображения. Аргумент *interpolation* контролирует методику преобразования. Интерполяция возникает в момент уменьшения исходного изображения и пиксель на конечном изображении как бы попадает между пикселями на исходном изображении. Интерполяция так же возникает в момент увеличения исходного изображения. В любом случае, существует несколько вариантов для вычисления значений таких пикселей. Простейший подход - получить значение масштабированного пикселя за счет ближайшего пикселя на исходном изображении - это соответствует опции *CV_INTER_NN*. Другой вариант - линейное взвешивание пикселей блоками по 2х2 пикселя вокруг исходного пикселя учитывая их близость к пикселю-приемнику (опция *CV_INTER_LINEAR*). Так же возможно мысленно поместить масштабный пиксель поверх старых пикселей, а затем усреднить значения в них (опция *CV_INTER_AREA*). И последний вариант - подгонка кубического сплайна под блок 4х4 пикселя в исходном изображении с последующим рассчётом соответствующего значения из подогнанного сплайна (опция *CV_INTER_CUBIC*).

