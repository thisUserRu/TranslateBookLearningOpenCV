## [П]|(РС]|(РП) Конструирование двух и трех мерных линий

!!! Fitting - конструирование

В заключении будет рассмотрено конструирование линий. Данная задача может возникнуть по многих причинам и во многих контекстах. Данная тема выбрана не случайно, т.к. одной из наиболее часто возникающей ситуацией, с которой связано конструирование линии, является анализ трехмерных точек (хотя описываемые в данном разделе функции могут конструировать и двумерные линии). Алгоритмы конструирования линии как правило используют статистически надежные методы. В OpenCV алгоритм конструирования линии представлен функцией *cvFitLine()*.

```cpp
	void cvFitLine(
		 const CvArr* 	points
		,int 			dist_type
		,double 		param
		,double 		reps
		,double 		aeps
		,float* 		line
	);
```

Массив *points* может быть матрицей вещественных значений размера Nx2 или Nx3 (вмещающая двух или трех мерные точки) или последовательностью структур *cvPointXXX*. (В данном случае *XXX* может быть заменено на *2D32f* или *3D64f*). Аргумент *dist_type* это метрика расстояния, которая должна быть сведена к минимуму для всех точек (таблица 12-3).

Таблица 12-3. Метрики, используемые для вычисления значений dist_type

| Значение dist_type | Метрика |
| -- | -- |
| CV_DIST_L2 | ![Формула 12-95 не найдена](Images/Frml_12_95.jpg) |
| CV_DIST_L1 | ![Формула 12-96 не найдена](Images/Frml_12_96.jpg) |
| CV_DIST_L12 | ![Формула 12-97 не найдена](Images/Frml_12_97.jpg) |
| CV_DIST_FAIR | ![Формула 12-98 не найдена](Images/Frml_12_98.jpg) |
| CV_DIST_WELSCH | ![Формула 12-99 не найдена](Images/Frml_12_99.jpg) |
| CV_DIST_HUBER | ![Формула 12-100 не найдена](Images/Frml_12_100.jpg) |

Параметр *param* используется для установки параметра C из таблицы 12-3. В случае установки данного параметра в 0, значение будет соответствовать табличному в зависимости от выбора.

Аргумент *line* это место, куда будет сохранен результат. Если *points* это массив Nx2, то *line* должен быть указателем на вещественный массив размера четыре (т.е. *float array[4]*). Если *points* это массив Nx3, то *line* должен быть указателем на вещественнй массив размера шесть (т.е. *float array[6]*). В первом случае возвращаемыми значениями будут (![Формула 12-101 не найдена](Images/Frml_12_101.jpg), ![Формула 12-102 не найдена](Images/Frml_12_102.jpg), ![Формула 12-90 не найдена](Images/Frml_12_90.jpg), ![Формула 12-91 не найдена](Images/Frml_12_91.jpg)), где (![Формула 12-101 не найдена](Images/Frml_12_101.jpg), ![Формула 12-102 не найдена](Images/Frml_12_102.jpg)) это нормированный вектор параллельный конструируемой линии, а (![Формула 12-90 не найдена](Images/Frml_12_90.jpg), ![Формула 12-91 не найдена](Images/Frml_12_91.jpg)) это точка на линии. Аналогичным образом, для трехмерного случая, возвращаемыми значениями будут (![Формула 12-101 не найдена](Images/Frml_12_101.jpg), ![Формула 12-102 не найдена](Images/Frml_12_102.jpg), ![Формула 12-103 не найдена](Images/Frml_12_103.jpg), ![Формула 12-90 не найдена](Images/Frml_12_90.jpg), ![Формула 12-91 не найдена](Images/Frml_12_91.jpg), ![Формула 12-104 не найдена](Images/Frml_12_104.jpg)), где (![Формула 12-101 не найдена](Images/Frml_12_101.jpg), ![Формула 12-102 не найдена](Images/Frml_12_102.jpg), ![Формула 12-103 не найдена](Images/Frml_12_103.jpg)) это нормированный вектор параллельный конструируемой линии, а (![Формула 12-90 не найдена](Images/Frml_12_90.jpg), ![Формула 12-91 не найдена](Images/Frml_12_91.jpg), ![Формула 12-104 не найдена](Images/Frml_12_104.jpg)) является точкой на этой линии. Учитывая представление линии, оценка точности параметров *reps* и *aeps* следующая: *reps* требуются оценки точности *x0, y0[, z0]*, а *aeps* требуется угловая точность *vx, vy[, vz]*. В документации по OpenCV рекомендуется использовать значение точности 0.01 в обоих случаях.

*cvFitLine()* может конструировать двух или трех мерные линии. Конструирование двумерных линий обычно важно в общем (пример 12-4, автор книги выражает благодарность за предоставленный пример **Vadim Pisarevsky**), а конструирование трехмерных линий крайне важно в OpenCV в частности (глава 14). В начале представленного примера синтезируются некоторые двумерные шумовые точки вокруг линии, а затем добавляются случайные точки, которые не имеют ничего общего с линией (и именуемые *выбросами*), а в заключении конструируется линия по полученным точкам и отображается на экране. Функция *cvFitLine()* хорошо справляется с выбросами; это крайне важно в реальных приложениях, где некоторые измерения могут быть сильно повреждены из-за шума, отказа датчика или по каким-либо другим причинам.

Пример 12-4. Конструирование двумерной линии

```cpp
#include "cv.h"
#include "highgui.h"
#include <math.h>

int main( int argc, char** argv ) {
	IplImage* img = cvCreateImage( cvSize( 500, 500 ), 8, 3 );
	CvRNG rng = cvRNG( -1 );

	cvNamedWindow( "fitline", 1 );
	
	for(;;) {
		char 		key;
		int 		i;
		int 		count 		= cvRandInt(&rng)%100 + 1;
		int 		outliers 	= count/5;
		float 		a 			= cvRandReal(&rng)*200;
		float 		b 			= cvRandReal(&rng)*40;
		float 		angle 		= cvRandReal(&rng)*CV_PI;
		float 		cos_a 		= cos(angle);
		float 		sin_a 		= sin(angle);
		CvPoint 	pt1, pt2;
		CvPoint* 	points 		= (CvPoint*)malloc( count * sizeof(points[0]) );
		CvMat 		pointMat 	= cvMat( 1, count, CV_32SC2, points );
		float 		line[4];
		float 		d, t;

		b = MIN( a*0.3, b );
		
		// Генерация точек, близких к линии
		//
		for( i = 0; i < count - outliers; i++ ) {
			float x = (cvRandReal(&rng)*2-1)*a;
			float y = (cvRandReal(&rng)*2-1)*b;
			points[i].x = cvRound(x*cos_a - y*sin_a + img->width/2);
			points[i].y = cvRound(x*sin_a + y*cos_a + img->height/2);
		}

		// Генерация "completely off" точек
		//
		for( ; i < count; i++ ) {
			points[i].x = cvRandInt(&rng) % img->width;
			points[i].y = cvRandInt(&rng) % img->height;
		}

		// Поиск оптимальной линии
		//
		cvFitLine( &pointMat, CV_DIST_L1, 1, 0.001, 0.001, line );
		cvZero( img );

		// Отображение точек
		//
		for( i = 0; i < count; i++ )
		cvCircle( 
					 img
					,points[i]
					,2
					,(i < count – outliers) ? CV_RGB(255, 0, 0) : CV_RGB(255, 255, 0)
					,CV_FILLED
					,CV_AA
					,0
		);

		// ... и достаточно длинной линии, чтобы пересечь все изображение
		// 
		d = sqrt( (double)line[0]*line[0] + (double)line[1]*line[1] );
		line[0] /= d;
		line[1] /= d;
		t = (float)(img->width + img->height);
		pt1.x = cvRound(line[2] - line[0]*t);
		pt1.y = cvRound(line[3] - line[1]*t);
		pt2.x = cvRound(line[2] + line[0]*t);
		pt2.y = cvRound(line[3] + line[1]*t);
		cvLine( img, pt1, pt2, CV_RGB(0,255,0), 3, CV_AA, 0 );

		cvShowImage("fitline", img );
		
		key = (char) cvWaitKey(0);
		
		if( key == 27 || key == ‘q’ || key == ‘Q’ ) // ‘ESC’
			break;

		free( points );
	}

	cvDestroyWindow( "fitline" );
	
	return 0;
}
```