## [П]|(РС]|(РП) Проекции

После выполнения калибровки камеры (глава 11), возможно однозначно спроецировать точки материального мира на изображение. Это означает, что координаты положения точек материального мира, связанные с камерой, можно вычислить, где должна появиться на фотоприёмнике, в пикселях, внешняя трехмерная точка. В OpenCV данное преобразование может выполнить функция *cvProjectPoints2()*:

```cpp
void cvProjectPoints2(
 const CvMat* object_points
,const CvMat* rotation_vector
,const CvMat* translation_vector
,const CvMat* intrinsic_matrix
,const CvMat* distortion_coeffs
,CvMat* image_points
,CvMat* dpdrot = NULL
,CvMat* dpdt = NULL
,CvMat* dpdf = NULL
,CvMat* dpdc = NULL
,CvMat* dpddist = NULL
,double aspectRatio = 0
);
```

На первый взгляд количество аргументов может быть немного пугающим, но на самом деле данная функция проста в использовании. Функция была разработана, чтобы приспособиться (очень обобщенно) к обстоятельствам, при которых проекционные точки должны расположиться на некотором твердом теле. В этом случае, естественно представить точки не просто как список положений в системе координат камеры, но и как список положения объекта в центре системы координат собственного тела; тогда можно добавить вращение и перемещение указав отношение между координатами объекта и системой координат камеры. На самом деле, *cvProjectPoints2()* используется внутри *cvCalibrateCamera2()*. Все дополнительные аргументы предназначены, прежде всего, для *cvCalibrateCamera2()*, но опытные пользователи могут приспособить их и под свои нужды.

Первый аргумент *object_points* это список проецируемых точек, представляющий из себя матрицу Nx3 и содержащий положения точки. Положения этих точек могут быть предоставлены в системе координат объекта, с последующей передачей матриц 3x1 *rotation_vector* (как правило, представление Rodrigues) и *translation_vector*, связывающие две координаты. Если в конкретном случае удобнее работать непосредственно в системе координат камеры, то можно просто передать *object_points* в этой системе координат, а для *rotation_vector* и *translation_vector* установить все значения в 0 (при этом стоит помнить, что вектор вращения является представлением поворота вида ось-угол, поэтому установка всех значений в 0 означает, что вектор имеет нулевую величину, соответственно "вращения нет").

*intrinsic_matrix* и *distortion_coeffs* - это матрица внутренних параметров  и коэффициенты искажения соответственно, которые приходят от *cvCalibrateCamera2()* (глава 11). Аргумент *image_points* это матрица Nx2, в которую будет записан вычисленный результат.

И наконец, длинный список дополнительных аргументов *dpdrot*, *dpdt*, *dpdf*, *dpdc* и *dpddist* - это все частные производные матрицы Jacobian. Эти матрицы связывают точки изображения с каждым из различных входных параметров. В частности: *dpdrot* это матрица Nx3 частных производных точек изображения по отношению к вектору вращения; *dpdt* это матрица Nx3 частных производных точек изображения по отношению к вектору перемещения; *dpdf* это матрица Nx2 частных производных точек изображения по отношению к ![Формула 11- не найдена](Chapter11/Images/Frml_11_.jpg) и ![Формула 11- не найдена](Chapter11/Images/Frml_11_.jpg); *dpdc* это матрица Nx2 частных производных точек изображения по отношению к ![Формула 11- не найдена](Chapter11/Images/Frml_11_.jpg) и ![Формула 11- не найдена](Chapter11/Images/Frml_11_.jpg); *dpddist* это матрица Nx4 частных производных точек изображения по отношению к коэффициентам искажения. В большинстве случаев они не используются (значение NULL). Последний параметр *aspectRatio* также необязателен; он используется для производных только тогда, когда соотношение сторон фиксировано в *cvCalibrateCamera2()* или *cvStereoCalibrate()*. Если этот параметр не 0, то производные *dpdf* будут скорректированы.