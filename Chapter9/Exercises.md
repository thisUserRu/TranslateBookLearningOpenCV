## [П]|[РС]|(РП) Упражнения

1. Используя функцию *cvRunningAvg()*, повторно реализуйте метод усреднения фона. Для того, чтобы сделать это, изучите скользящее среднее значение пикселей на сцене, чтобы найти абсолютную разницу среднего и скользящего среднего (*cvAbsDiff()*) в качестве прокси стандартного отклонения изображения.

2. Тени часто являются проблемой при вычитании фона, т.к. их можно принять за объекты переднего плана. Воспользуйтесь методом вычитания фона усреднения или кодовой книги. Смоделируйте ситуацию, в которой человек перемещается на переднем плане. Тени будут "исходить" от нижней части объекта переднего плана.

	a. На улице тенями являются более темные и синеватые участки; используйте данный факт, что удалить тени.

	b. В помещение тенями являются более темные участки; используйте данный факт, чтобы удалить тени.

3. Простые модели фона, представленные в данной главе, зачастую весьма чувствительны к их пороговым параметрам. В главе 10 будет показано, как отслеживать движения, что может быть использовано в качестве "реальной" проверки модели фона и его порогов. Данные знания так же можно использовать, чтобы распознать человека по "калибровочным движениям" на переднем плане камеры: ищется движущийся объект и настраиваются параметры до тех пор, пока на переднем плане объект не будет соответствовать границам движения. Так же можно использовать определенные шаблоны на самом калиброванном объекте (или фоне) для реальной проверки и настройки направляющего, чтобы знать, какая часть фона является замкнутой.

	a. Изменить код, чтобы включить режим авто калибровки. Изучите модель фона, а затем разместите цветной объект на сцене. Используйте цвет для поиска цветного объекта, а затем используйте этот объект, чтобы автоматически установить пороговые значения фона для сегментации объекта. При этом можно оставить объект на сцене для плавной перенастройки.

	b. Используйте полученное решение для удаления теней из упражнения 2.

4. Используйте фоновую сегментацию для сегментации человеческой руки. Исследуйте влияние различных параметров и значений по умолчанию на процедуру *find_connected_components()*. Отобразите результаты различных установок следующих параметров:

	a. *poly1_hull0*

	b. *perimScale*

	c. *CVCONTOUR_APPROX_LEVEL*

	d. *CVCLOSE_ITR*

5. В 2005 году на *DARPA Grand Challenge robot race*, авторы *Stanford team* использовали своего рода алгоритм цветной кластеризации для отделения дороги от недороги. Цвета выбирались лазерной трапецией клочка дороги, взятой перед машиной. Другие цвета на сцене, близкие по цвету к данному клочку принимались за связанные компоненты и помечались как дорога. Взгляните на рисунок 9-18, где алгоритм водораздела был использован для сегментации дороги (отмечена трапецией), а все что не дорога отмечено перевернутой "U". Предположим, что имеется возможность автоматически генерировать эти метки. Что в таком случае может пойти не так в этом методе сегментации дороги?

	Подсказка: посмотрите на рисунок 9-8 и предположите за счет каких вещей можно расширить трапецию дороги.

	![Рисунок 9-18 не найден](Images/Pic_9_18.jpg)

	Рисунок 9-18. Использование алгоритма водораздела для идентификации дороги: размещение маркеров на оригинальном изображение (слева) и результат применения алгоритма - сегментация дороги (справа)

6. Inpainting работает наиболее хорошо для восстановления письменного текста на наиболее текстурированных областях. Что будет, если письменный текст будет неразборчив? Попробуйте.

7. Это может быть немного медленно, однако попробуйте запустить фоновую сегментацию с предварительной предобработкой исходного видеопотока при помощи *cvPyrMeanShiftFiltering()*. Т.е. в начале на исходном потоке выполняется *mean-shift* сегментация, а затем выполняется изучение фона - а затем и тестирование переднего плана - при помощи метода кодовой книги.

	a. Отобразите результаты до выполнения *mean-shift* сегментации.

	b. Попробуйте систематически изменять *max_level*, *spatialRadius* и *colorRadius* *mean-shift* сегментации. 

8. Насколько хорошо inpainting работает с письменным текстом, который обработан *mean-shift* сегментацией? Поэкспериментируйте с настройками и отобразите результаты. 

9. Модифицируйте код *.../opencv/samples/delaunay.c* так, чтобы появилась возможность отслеживания двойного нажатия мыши в указанном месте (вместо существующего метода, где место выбирается случайным образом). Поэкспериментируйте с результатами триангуляции.

10. Вновь модифицируйте *delaunay.c* так, чтобы можно было бы задействовать клавиатуру для рисования выпуклой оболочки, на основе которой бы строилось множество точек.

11. Можно ли говорить о триангуляции Delaunay, имея три точки на линии?

12. Является ли триангуляция на рисунке 9-19(a) триангуляцией Delaunay? Если да, то объясните почему. Если нет, то как необходимо изменить фигуру, чтобы это была триангуляция Dekaunay?

13. Выполните триангуляцию Delaunay на множестве точек с рисунка 9-19(b) вручную. Для выполнения этого задания не используйте внешний фиктивный внешний треугольник.

![Рисунок 9-19 не найден](Images/Pic_9_19.jpg)

Рисунок 9-19. Упражнение 12 и 13